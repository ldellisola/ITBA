<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>03 - Text Mining.md</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        html {
    overflow-x: initial !important;
}

:root {
    --bg-color: #ffffff;
    --text-color: #333333;
    --select-text-bg-color: #B5D6FC;
    --select-text-font-color: auto;
    --monospace: "Lucida Console", Consolas, "Courier", monospace;
}

html {
    font-size: 14px;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
}

body {
    margin: 5%;
    padding: 0px;
    height: auto;
    bottom: 0px;
    top: 0px;
    left: 0px;
    right: 0px;
    font-size: 1rem;
    line-height: 1.42857;
    overflow-x: hidden;
    background: inherit;
    tab-size: 4;
    max-width: 100%;
}

iframe {
    margin: auto;
}

a.url {
    word-break: break-all;
}

a:active, a:hover {
    outline: 0px;
}

.in-text-selection, ::selection {
    text-shadow: none;
    background: var(--select-text-bg-color);
    color: var(--select-text-font-color);
}

#write {
    margin: 0px auto;
    height: auto;
    width: inherit;
    word-break: normal;
    overflow-wrap: break-word;
    position: relative;
    white-space: normal;
    overflow-x: visible;
    padding-top: 40px;
}

#write.first-line-indent p {
    text-indent: 2em;
}

#write.first-line-indent li p, #write.first-line-indent p * {
    text-indent: 0px;
}

#write.first-line-indent li {
    margin-left: 2em;
}

.for-image #write {
    padding-left: 8px;
    padding-right: 8px;
}

body.typora-export {
    padding-left: 30px;
    padding-right: 30px;
}

.typora-export .footnote-line, .typora-export li, .typora-export p {
    white-space: pre-wrap;
}

@media screen and (max-width: 500px) {
    body.typora-export {
        padding-left: 0px;
        padding-right: 0px;
    }

    #write {
        padding-left: 20px;
        padding-right: 20px;
    }

    .CodeMirror-sizer {
        margin-left: 0px !important;
    }

    .CodeMirror-gutters {
        display: none !important;
    }
}

#write li > figure:last-child {
    margin-bottom: 0.5rem;
}

#write ol, #write ul {
    position: relative;
}

img {
    max-width: 100%;
    vertical-align: middle;
}

button, input, select, textarea {
    color: inherit;
    font: inherit;
}

input[type="checkbox"], input[type="radio"] {
    line-height: normal;
    padding: 0px;
}

*, ::after, ::before {
    box-sizing: border-box;
}

#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre {
    width: inherit;
}

#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p {
    position: relative;
}

p {
    line-height: inherit;
}

h1, h2, h3, h4, h5, h6 {
    break-after: avoid-page;
    break-inside: avoid;
    orphans: 2;
}

p {
    orphans: 4;
}

h1 {
    font-size: 2rem;
    text-align: center
}

h2 {
    font-size: 1.8rem;
}

h3 {
    font-size: 1.6rem;
}

h4 {
    font-size: 1.4rem;
}

h5 {
    font-size: 1.2rem;
}

h6 {
    font-size: 1rem;
}

.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p {
    margin-top: 1rem;
    margin-bottom: 1rem;
}

.hidden {
    display: none;
}

.md-blockmeta {
    color: rgb(204, 204, 204);
    font-weight: 700;
    font-style: italic;
}

a {
    cursor: pointer;
}

sup.md-footnote {
    padding: 2px 4px;
    background-color: rgba(238, 238, 238, 0.7);
    color: rgb(85, 85, 85);
    border-radius: 4px;
    cursor: pointer;
}

sup.md-footnote a, sup.md-footnote a:hover {
    color: inherit;
    text-transform: inherit;
    text-decoration: inherit;
}

#write input[type="checkbox"] {
    cursor: pointer;
    width: inherit;
    height: inherit;
}

figure {
    overflow-x: auto;
    margin: 1.2em 0px;
    max-width: calc(100% + 16px);
    padding: 0px;
}

figure > table {
    margin: 0px !important;
}

tr {
    break-inside: avoid;
    break-after: auto;
}

thead {
    display: table-header-group;
}

table {
    border-collapse: collapse;
    border-spacing: 0px;
    width: 100%;
    overflow: auto;
    break-inside: auto;
    text-align: left;
}

table.md-table td {
    min-width: 32px;
}

.CodeMirror-gutters {
    border-right: 0px;
    background-color: inherit;
}

.CodeMirror-linenumber {
    user-select: none;
}

.CodeMirror {
    text-align: left;
}

.CodeMirror-placeholder {
    opacity: 0.3;
}

.CodeMirror pre {
    padding: 0px 4px;
}

.CodeMirror-lines {
    padding: 0px;
}

div.hr:focus {
    cursor: none;
}

#write pre {
    white-space: pre-wrap;
}

#write.fences-no-line-wrapping pre {
    white-space: pre;
}

#write pre.ty-contain-cm {
    white-space: normal;
}

.CodeMirror-gutters {
    margin-right: 4px;
}

.md-fences {
    font-size: 0.9rem;
    display: block;
    break-inside: avoid;
    text-align: left;
    overflow: visible;
    white-space: pre;
    background: inherit;
    position: relative !important;
}

.md-diagram-panel {
    width: 100%;
    margin-top: 10px;
    text-align: center;
    padding-top: 0px;
    padding-bottom: 8px;
    overflow-x: auto;
}

#write .md-fences.mock-cm {
    white-space: pre-wrap;
}

.md-fences.md-fences-with-lineno {
    padding-left: 0px;
}

#write.fences-no-line-wrapping .md-fences.mock-cm {
    white-space: pre;
    overflow-x: auto;
}

.md-fences.mock-cm.md-fences-with-lineno {
    padding-left: 8px;
}

.CodeMirror-line, twitterwidget {
    break-inside: avoid;
}

.footnotes {
    opacity: 0.8;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-bottom: 1em;
}

.footnotes + .footnotes {
    margin-top: 0px;
}

.md-reset {
    margin: 0px;
    padding: 0px;
    border: 0px;
    outline: 0px;
    vertical-align: top;
    background: 0px 0px;
    text-decoration: none;
    text-shadow: none;
    float: none;
    position: static;
    width: auto;
    height: auto;
    white-space: nowrap;
    cursor: inherit;
    -webkit-tap-highlight-color: transparent;
    line-height: normal;
    font-weight: 400;
    text-align: left;
    box-sizing: content-box;
    direction: ltr;
}

li div {
    padding-top: 0px;
}

blockquote {
    margin: 1rem 0px;
}

li .mathjax-block, li p {
    margin: 0.5rem 0px;
}

li {
    margin: 0px;
    position: relative;
}

blockquote > :last-child {
    margin-bottom: 0px;
}

blockquote > :first-child, li > :first-child {
    margin-top: 0px;
}

.footnotes-area {
    color: rgb(136, 136, 136);
    margin-top: 0.714rem;
    padding-bottom: 0.143rem;
    white-space: normal;
}

#write .footnote-line {
    white-space: pre-wrap;
}

@media print {
    body, html {
        border: 1px solid transparent;
        height: 99%;
        break-after: avoid;
        break-before: avoid;
    }

    #write {
        margin-top: 0px;
        padding-top: 0px;
        border-color: transparent !important;
    }

    .typora-export * {
        -webkit-print-color-adjust: exact;
    }

    html.blink-to-pdf {
        font-size: 13px;
    }

    .typora-export #write {
        padding-left: 32px;
        padding-right: 32px;
        padding-bottom: 0px;
        break-after: avoid;
    }

    .typora-export #write::after {
        height: 0px;
    }
}

.footnote-line {
    margin-top: 0.714em;
    font-size: 0.7em;
}

a img, img a {
    cursor: pointer;
}

pre.md-meta-block {
    font-size: 0.8rem;
    min-height: 0.8rem;
    white-space: pre-wrap;
    background: rgb(204, 204, 204);
    display: block;
    overflow-x: hidden;
}

p > .md-image:only-child:not(.md-img-error) img, p > img:only-child {
    display: block;
    margin: auto;
}

p > .md-image:only-child {
    display: inline-block;
    width: 100%;
}

#write .MathJax_Display {
    margin: 0.8em 0px 0px;
}

.md-math-block {
    width: 100%;
}

.md-math-block:not(:empty)::after {
    display: none;
}

[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus {
    outline: 0px;
    box-shadow: none;
}

.md-task-list-item {
    position: relative;
    list-style-type: none;
}

.task-list-item.md-task-list-item {
    padding-left: 0px;
}

.md-task-list-item > input {
    position: absolute;
    top: 0px;
    left: 0px;
    margin-left: -1.2em;
    margin-top: calc(1em - 10px);
    border: none;
}

.math {
    font-size: 1rem;
}

.md-toc {
    min-height: 3.58rem;
    position: relative;
    font-size: 0.9rem;
    border-radius: 10px;
}

.md-toc-content {
    position: relative;
    margin-left: 0px;
}

.md-toc-content::after, .md-toc::after {
    display: none;
}

.md-toc-item {
    display: block;
    color: rgb(65, 131, 196);
}

.md-toc-item a {
    text-decoration: none;
}

.md-toc-inner:hover {
    text-decoration: underline;
}

.md-toc-inner {
    display: inline-block;
    cursor: pointer;
}

.md-toc-h1 .md-toc-inner {
    margin-left: 0px;
    font-weight: 700;
}

.md-toc-h2 .md-toc-inner {
    margin-left: 2em;
}

.md-toc-h3 .md-toc-inner {
    margin-left: 4em;
}

.md-toc-h4 .md-toc-inner {
    margin-left: 6em;
}

.md-toc-h5 .md-toc-inner {
    margin-left: 8em;
}

.md-toc-h6 .md-toc-inner {
    margin-left: 10em;
}

@media screen and (max-width: 48em) {
    .md-toc-h3 .md-toc-inner {
        margin-left: 3.5em;
    }

    .md-toc-h4 .md-toc-inner {
        margin-left: 5em;
    }

    .md-toc-h5 .md-toc-inner {
        margin-left: 6.5em;
    }

    .md-toc-h6 .md-toc-inner {
        margin-left: 8em;
    }
}

a.md-toc-inner {
    font-size: inherit;
    font-style: inherit;
    font-weight: inherit;
    line-height: inherit;
}

.footnote-line a:not(.reversefootnote) {
    color: inherit;
}

.md-attr {
    display: none;
}

.md-fn-count::after {
    content: ".";
}

code, pre, samp, tt {
    font-family: var(--monospace);
}

kbd {
    margin: 0px 0.1em;
    padding: 0.1em 0.6em;
    font-size: 0.8em;
    color: rgb(36, 39, 41);
    background: rgb(255, 255, 255);
    border: 1px solid rgb(173, 179, 185);
    border-radius: 3px;
    box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset;
    white-space: nowrap;
    vertical-align: middle;
}

.md-comment {
    color: rgb(162, 127, 3);
    opacity: 0.8;
    font-family: var(--monospace);
}

code {
    text-align: left;
    vertical-align: initial;
}

a.md-print-anchor {
    white-space: pre !important;
    border-width: initial !important;
    border-style: none !important;
    border-color: initial !important;
    display: inline-block !important;
    position: absolute !important;
    width: 1px !important;
    right: 0px !important;
    outline: 0px !important;
    background: 0px 0px !important;
    text-decoration: initial !important;
    text-shadow: initial !important;
}

.md-inline-math .MathJax_SVG .noError {
    display: none !important;
}

.html-for-mac .inline-math-svg .MathJax_SVG {
    vertical-align: 0.2px;
}

.md-math-block .MathJax_SVG_Display {
    text-align: center;
    margin: 0px;
    position: relative;
    text-indent: 0px;
    max-width: none;
    max-height: none;
    min-height: 0px;
    min-width: 100%;
    width: auto;
    overflow-y: hidden;
    display: block !important;
}

.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display {
    width: auto;
    margin: inherit;
    display: inline-block !important;
}

.MathJax_SVG .MJX-monospace {
    font-family: var(--monospace);
}

.MathJax_SVG .MJX-sans-serif {
    font-family: sans-serif;
}

.MathJax_SVG {
    display: inline;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    zoom: 90%;
    text-indent: 0px;
    text-align: left;
    text-transform: none;
    letter-spacing: normal;
    word-spacing: normal;
    overflow-wrap: normal;
    white-space: nowrap;
    float: none;
    direction: ltr;
    max-width: none;
    max-height: none;
    min-width: 0px;
    min-height: 0px;
    border: 0px;
    padding: 0px;
    margin: 0px;
}

.MathJax_SVG * {
    transition: none 0s ease 0s;
}

.MathJax_SVG_Display svg {
    vertical-align: middle !important;
    margin-bottom: 0px !important;
    margin-top: 0px !important;
}

.os-windows.monocolor-emoji .md-emoji {
    font-family: "Segoe UI Symbol", sans-serif;
}

.md-diagram-panel > svg {
    max-width: 100%;
}

[lang="flow"] svg, [lang="mermaid"] svg {
    max-width: 100%;
    height: auto;
}

[lang="mermaid"] .node text {
    font-size: 1rem;
}

table tr th {
    border-bottom: 0px;
}

video {
    max-width: 100%;
    display: block;
    margin: 0px auto;
}

iframe {
    max-width: 100%;
    width: 100%;
    border: none;
}

.highlight td, .highlight tr {
    border: 0px;
}

svg[id^="mermaidChart"] {
    line-height: 1em;
}

mark {
    background: rgb(255, 255, 0);
    color: rgb(0, 0, 0);
}

.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong {
    color: inherit;
}

mark .md-meta {
    color: rgb(0, 0, 0);
    opacity: 0.3 !important;
}


.CodeMirror {
    height: auto;
}

.CodeMirror.cm-s-inner {
    background: inherit;
}

.CodeMirror-scroll {
    overflow: auto hidden;
    z-index: 3;
}

.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler {
    background-color: rgb(255, 255, 255);
}

.CodeMirror-gutters {
    border-right: 1px solid rgb(221, 221, 221);
    background: inherit;
    white-space: nowrap;
}

.CodeMirror-linenumber {
    padding: 0px 3px 0px 5px;
    text-align: right;
    color: rgb(153, 153, 153);
}

.cm-s-inner .cm-keyword {
    color: rgb(119, 0, 136);
}

.cm-s-inner .cm-atom, .cm-s-inner.cm-atom {
    color: rgb(34, 17, 153);
}

.cm-s-inner .cm-number {
    color: rgb(17, 102, 68);
}

.cm-s-inner .cm-def {
    color: rgb(0, 0, 255);
}

.cm-s-inner .cm-variable {
    color: rgb(0, 0, 0);
}

.cm-s-inner .cm-variable-2 {
    color: rgb(0, 85, 170);
}

.cm-s-inner .cm-variable-3 {
    color: rgb(0, 136, 85);
}

.cm-s-inner .cm-string {
    color: rgb(170, 17, 17);
}

.cm-s-inner .cm-property {
    color: rgb(0, 0, 0);
}

.cm-s-inner .cm-operator {
    color: rgb(152, 26, 26);
}

.cm-s-inner .cm-comment, .cm-s-inner.cm-comment {
    color: rgb(170, 85, 0);
}

.cm-s-inner .cm-string-2 {
    color: rgb(255, 85, 0);
}

.cm-s-inner .cm-meta {
    color: rgb(85, 85, 85);
}

.cm-s-inner .cm-qualifier {
    color: rgb(85, 85, 85);
}

.cm-s-inner .cm-builtin {
    color: rgb(51, 0, 170);
}

.cm-s-inner .cm-bracket {
    color: rgb(153, 153, 119);
}

.cm-s-inner .cm-tag {
    color: rgb(17, 119, 0);
}

.cm-s-inner .cm-attribute {
    color: rgb(0, 0, 204);
}

.cm-s-inner .cm-header, .cm-s-inner.cm-header {
    color: rgb(0, 0, 255);
}

.cm-s-inner .cm-quote, .cm-s-inner.cm-quote {
    color: rgb(0, 153, 0);
}

.cm-s-inner .cm-hr, .cm-s-inner.cm-hr {
    color: rgb(153, 153, 153);
}

.cm-s-inner .cm-link, .cm-s-inner.cm-link {
    color: rgb(0, 0, 204);
}

.cm-negative {
    color: rgb(221, 68, 68);
}

.cm-positive {
    color: rgb(34, 153, 34);
}

.cm-header, .cm-strong {
    font-weight: 700;
}

.cm-del {
    text-decoration: line-through;
}

.cm-em {
    font-style: italic;
}

.cm-link {
    text-decoration: underline;
}

.cm-error {
    color: red;
}

.cm-invalidchar {
    color: red;
}

.cm-constant {
    color: rgb(38, 139, 210);
}

.cm-defined {
    color: rgb(181, 137, 0);
}

div.CodeMirror span.CodeMirror-matchingbracket {
    color: rgb(0, 255, 0);
}

div.CodeMirror span.CodeMirror-nonmatchingbracket {
    color: rgb(255, 34, 34);
}

.cm-s-inner .CodeMirror-activeline-background {
    background: inherit;
}

.CodeMirror {
    position: relative;
    overflow: hidden;
}

.CodeMirror-scroll {
    height: 100%;
    outline: 0px;
    position: relative;
    box-sizing: content-box;
    background: inherit;
}

.CodeMirror-sizer {
    position: relative;
}

.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar {
    position: absolute;
    z-index: 6;
    display: none;
}

.CodeMirror-vscrollbar {
    right: 0px;
    top: 0px;
    overflow: hidden;
}

.CodeMirror-hscrollbar {
    bottom: 0px;
    left: 0px;
    overflow: hidden;
}

.CodeMirror-scrollbar-filler {
    right: 0px;
    bottom: 0px;
}

.CodeMirror-gutter-filler {
    left: 0px;
    bottom: 0px;
}

.CodeMirror-gutters {
    position: absolute;
    left: 0px;
    top: 0px;
    padding-bottom: 30px;
    z-index: 3;
}

.CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    box-sizing: content-box;
    padding-bottom: 30px;
    margin-bottom: -32px;
    display: inline-block;
}

.CodeMirror-gutter-wrapper {
    position: absolute;
    z-index: 4;
    background: 0px 0px !important;
    border: none !important;
}

.CodeMirror-gutter-background {
    position: absolute;
    top: 0px;
    bottom: 0px;
    z-index: 4;
}

.CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
}

.CodeMirror-lines {
    cursor: text;
}

.CodeMirror pre {
    border-radius: 0px;
    border-width: 0px;
    background: 0px 0px;
    font-family: inherit;
    font-size: inherit;
    margin: 0px;
    white-space: pre;
    overflow-wrap: normal;
    color: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
}

.CodeMirror-wrap pre {
    overflow-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
}

.CodeMirror-code pre {
    border-right: 30px solid transparent;
    width: fit-content;
}

.CodeMirror-wrap .CodeMirror-code pre {
    border-right: none;
    width: auto;
}

.CodeMirror-linebackground {
    position: absolute;
    left: 0px;
    right: 0px;
    top: 0px;
    bottom: 0px;
    z-index: 0;
}

.CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    overflow: auto;
}

.CodeMirror-wrap .CodeMirror-scroll {
    overflow-x: hidden;
}

.CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0px;
    overflow: hidden;
    visibility: hidden;
}

.CodeMirror-measure pre {
    position: static;
}

.CodeMirror div.CodeMirror-cursor {
    position: absolute;
    visibility: hidden;
    border-right: none;
    width: 0px;
}

.CodeMirror div.CodeMirror-cursor {
    visibility: hidden;
}

.CodeMirror-focused div.CodeMirror-cursor {
    visibility: inherit;
}

.cm-searching {
    background: rgba(255, 255, 0, 0.4);
}

@media print {
    .CodeMirror div.CodeMirror-cursor {
        visibility: hidden;
    }
}


:root {
    --side-bar-bg-color: white;
    --window-border: none;
    --search-select-bg-color: #575c61;
    --active-file-bg-color: #f1f4f5;
    --item-hover-bg-color: #f1f4f5;
    --item-hover-text-color: black;
    --control-text-color: #555;
}

@include-when-export url(https://raw.githubusercontent.com/slashfoo/lmweb/master/style/latinmodern-mono-light.css);

html {
    font-size: 12pt;
}

#write {
    font-family: "STIX2Text", "Times New Roman", "serif";
    line-height: 1.5em;
    padding: 10%;
    padding-top: 5%;
}

.file-list-item-summary {
    height: 36px;
}

.file-list-item {
    padding-top: 18px !important;
    padding-bottom: 18px;
}

#sidebar-loading-template.file-list-item {
    padding-top: 0 !important;
}

a, a:visited {
    color: #a00;
}

h1, h2, h3, h4, h5, h6 {
    font-family: inherit;
    line-height: 1.5em;
    margin-bottom: 1em;
    margin-top: 1em;
}

h1 {
    font-size: 2.4em;
}

#write h1 {
    text-align: center;
}

h2 {
    font-size: 1.8em;
}

h3 {
    font-size: 1.4em;
}

h4 {
    font-size: 1.2em;
}

h5 {
    font-size: 1.1em;
}

h6 {
    font-size: 1em;
}

p {
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: justify;
}

pre, code {
    font-family: 'Latin Modern Mono Light', "Latin Modern Mono", monospace !important;
    background-color: #ebebeb;
}

.footnotes {
    display: list-item;
    margin-left: 1em;
}

.md-fences {
    border: 1px solid;
}

.md-fences.md-fences-with-lineno {
    border: none;
}

.CodeMirror-linenumber {
    color: #333;
}

*.in-text-selection,
::selection,
.CodeMirror-selected {
    background: var(--search-select-bg-color);
    color: var(--search-select-text-color) !important;
    text-shadow: none;
}

a.md-toc-inner {
    color: var(--text-color);
}

.cm-s-typora-default .cm-link {
    color: #a00;
    text-decoration: underline;
}

.cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property {
    color: black;
}

#typora-source .CodeMirror-lines {
    -webkit-font-smoothing: auto;
    max-width: 1000px;
}

.md-def-name:before,
.md-def-name:after {
    color: #2d2d2d;
}

sup.md-footnote {
    background-color: initial;
    color: inherit;
}

mark {
    background: #fff387;
}

td, th {
    border: 1px solid;
    padding-left: 1ch;
    padding-right: 1ch;
}

/*table tr[cid]:first-child > td {
    border-top: 3px double;
}*/

th {
    border-bottom: 0;
    padding-top: 2px;
    background: #575c61;
    border-color: #333;
    color: #f3f3f3;
}

pre.md-meta-block {
    border: 1px solid #a2a9b1;
    background-color: #f8f9fa;
    padding: 5px;
    margin-bottom: 1em;
}

.task-list-item input:before {
    content: '\221A';
    display: inline-block;
    width: 1.25rem;
    height: 1.6rem;
    vertical-align: middle;
    text-align: center;
    color: #bbb;
    background-color: inherit;
}

.task-list-item input:checked:before,
.task-list-item input[checked]:before {
    color: inherit;
}

.md-task-list-item > input {
    top: auto;
    margin-left: -1.1em;
    font-size: 1.3em;
    margin-top: 0px;
    -webkit-appearance: none;
}

.md-task-list-item input:before {
    content: '\2610';
    display: inline-block;
    width: 1.25rem;
    height: 1.6rem;
    vertical-align: middle;
    text-align: center;
    color: #bbb;
    background-color: inherit;
}

.md-task-list-item input:checked:before,
.md-task-list-item input[checked]:before {
    color: inherit;
    content: '\2611';
}

.task-list-item {
    padding-left: 1.5em;
}

blockquote {
    font-style: italic;
    padding: 0.25em 24px;
    position: relative;
    color: #383838;
    border-left: 2px solid;
}

#write > blockquote {
    padding: 0.25em 30px;
    margin-left: -32px;
    width: calc(100% + 32px);
}

#write > .md-fences-with-lineno {
    margin-left: -33px;
    color: black;
}

.CodeMirror-linenumber {
    min-width: 25px;
}

.md-header {
    font-size: inherit !important;
}

/*blockquote:before {
    display: block;
    content: "\201C";
    font-size: 80px;
    position: absolute;
    left: -20px;
    top: -20px;
    color: #7a7a7a;
}*/




    </style>
</head>
<body>
<h1 id="text-mining">Text Mining</h1>
<p>Text mining is primarily aimed at extracting information and knowledge previously unknown to the user from text. This information may not even be known by the writer. This process involves several steps:</p>
<ul>
<li><p>Assemble a large number of documents</p>
</li>
<li><p><u>Preprocess those documents</u>:</p>
<p>The main idea of this step is to convert the raw text file into a well-defines sequence of linguistically-meaningful units. It is usually split into sentences or tokens (words).</p>
<p>For Tokenization we usually split the text into sentences or words using characters such as whitespace or punctuation symbols. This process is t</p>
</li>
<li><p>Perform text transformation and feature generation</p>
</li>
<li><p>Select only some features that are important to you</p>
</li>
<li><p>Pattern recognition</p>
</li>
<li><p>Interpret the patterns</p>
</li>
</ul>
<h2 id="issues">Issues</h2>
<p>There are a lot of issues with this process:</p>
<ul>
<li>High Dimensionality</li>
<li>Different terms for the same concept</li>
<li>The same term can identify more than one concept</li>
<li>The text is not structured</li>
</ul>
<h2 id="applications">Applications</h2>
<p>Text mining has a lots of applications, the most general uses are information retrieval for recommendation systems and information extraction. Among other uses we can find customer profile and social media analysis, document classifying and clustering, and  spam filtering or fraud detection.</p>
<h3 id="text-processing">Text Processing</h3>
<p>Text needs to be preprocessed to be machine understandable. This is done by converting a raw text file into a well defined sequence of linguistically-meaningful units, basically splitting the string into tokens (words) and handling special symbols such as dots, and whitespaces.</p>
<p>After this initial transformation, we may still need to process the text in many stages, such as part-of-speech tagging or Named Entity Recognition.</p>
<h4 id="tokenization">Tokenization</h4>
<p>Tokenization involves grouping sequences of characters into logical elements called tokens. The system that handles this process is known as a <strong>tokenizer</strong>. This process is trivial for a person familiar with the language structure but it is more complicated for a computer program as it is language-dependent.</p>
<h4 id="frequency-analysis">Frequency Analysis</h4>
<p>This is a basic way to analyze textual data and it is focused on computing the frequency distribution as a ranked list of terms.</p>
<h4 id="stemming-and-lemmatization">Stemming and Lemmatization</h4>
<p>The goal of this process is to reduce the dimensionality by converting each token to a standard form. <strong>Lemmatization</strong> tries to find the canonical form for a given words, for example, <em>&quot;are, is, was, were&quot;</em> are all part of the lemma <em>&quot;be&quot;</em>.</p>
<p><strong>Stemming</strong> does a similar thing by finding the root word from which suffixes can be attached. A good example of this is the word <em>&quot;waiting&quot;</em>, that comes the the root <em>&quot;wait&quot;</em>.</p>
<p>We can also use other techniques to reduce the dimensionality of a dataset. The easiest way is to remove tokens that do not provide anything to the context, such as <em>&quot;a, the, it, they&quot;</em>. Another method similar to lemmatization is to remove tokens using synonyms and antonyms.</p>
<h4 id="sentence-splitting">Sentence Splitting</h4>
<p>Identifying sentences in a txt is not a trivial process and heuristics can be used to improve it. This heuristics usually imply keeping track of words that are usually in the first or last position of sentences.</p>
<h4 id="n-grams">N-Grams</h4>
<p>N-Grams are a set of co-occurring words within a given window.</p>
<h4 id="part-of-speech-tagging">Part-of-Speech Tagging</h4>
<p>This is a linguistical analysis that assigns categories to words in a text. It cannot be 100% accurate because some words can be multiple things depending on the context. Here we can see a list of possible categories:</p>
<img src="Resources/03 - Text Mining/5978e872-6bcc-4016-b05a-f5957ae7f501.png" alt="5978e872-6bcc-4016-b05a-f5957ae7f501" style="scale:0.33;" />
<h4 id="phrase-detection">Phrase Detection</h4>
<p>We can use tokens and extra information acquired from PoS tagging of group tokens into <strong>chunks</strong>. The PoS data is very important as it allows you to use more specific chunking methods, such as <strong>Noun Phrase Chunking</strong>. This method is based on chunk grammar and it represents a set of rules that indicate how sentences should be chunked, for example a determiner should be follower by a number or adjective, and terminated by a noun.</p>
<h3 id="named-entity-recognition-ner">Named Entity Recognition (NER)</h3>
<p>This process tries to turn verbose text data into a more compacted structural form, and it uses a special kind of phrase detection. Among its subtasks we can find:</p>
<ul>
<li><u>Recognition</u>: Spotting text fragments with entity mentions</li>
<li><u>Classification</u>: Assigning class to an entity mention</li>
<li><u>Disambiguation via Linking</u>: Assigning an URI describing the entity, usually a Wikipedia link.</li>
</ul>
<p>NER systems are usually trained on a large corpus and are based on previously defined rules or lists of  proper nouns.</p>
<p>The result has significantly lower dimension and it is richer thanks to the disambiguation.</p>
<h3 id="relation-extraction">Relation Extraction</h3>
<p>This refers to extracting semantic relations between entities, for example saying a person lives in a place. Naïve approaches don't work well here, we have to use linguistic analysis.</p>
<h2 id="opinion-mining">Opinion Mining</h2>
<p>Opinion mining studies opinions, sentiments, emotions and related topics, and it is interested in identifying it in a text. This has a lot of practical applications, such as reviews, political opinion or influences over the stock market.</p>
<p>This process can be summarized in 3 stages:</p>
<ul>
<li><strong>Opinion Extraction</strong>: Extract the text that expresses an opinion</li>
<li><strong>Sentiment Analysis</strong>: Identify the polarity of an opinion</li>
<li><strong>Opinion Summarization</strong>: Identify the overall opinion.</li>
</ul>
<h3 id="sentiment-analysis">Sentiment Analysis</h3>
<p>There are several types of sentiment analysis:</p>
<ul>
<li>Document and sentence subjectivity and sentiment classification: This type is usually uses polarity classification, trying to decide if the text is positive, negative or neutral.</li>
<li>Feature/aspect sentiment identification: It determines the opinions or sentiments expressed on different features or aspects of entities.</li>
<li>Opinion search and retrieval: It finds public opinions about a particular entity or an aspect of the entity.</li>
<li>Opinion Spam Detection: detecting fake opinions or reviews</li>
</ul>
<p>A <strong>lexicon</strong> is a list with opinion words used in sentiment classification tasks. The appearance of a word of the list in a text means that the text contains that sentiment. This is used in <strong>lexicon-based sentiment</strong>.</p>
<p><strong>Supervised Sentiment Learning</strong> trains on annotated data such as reviews with ratings to categorize text whether as positive, negative or neutral. the learning is similar to classical document topic classification, the topic related words here are not important, but the sentiment is.</p>
<p>We can also do the same but without any supervision in <strong>unsupervised sentiment learning</strong>. For this type of learning we have to use PoS tagging to identify the context of the sentences, because isolated adjectives may not reveal the real opinion.</p>
<p>There are situations where adjectives can be good or bad depending on the context. This is called <strong>Sentiment Orientation of Phrases</strong> and we can estimate the semantic orientation using pointwise mutual information (PMI), which indicates the degree of statistical dependence between them:</p>
<div class="math">
\[
\text{PMI}(\text{term}_1,\text{term}_2) = \log_2\left(\frac{Pr(\text{term}_1 \land \text{term}_2)}{Pr(\text{term}_1)Pr(\text{term}_2)}\right)
\]</div>
<p>Where <span class="math">\(Pr(\text{term}_1 \land \text{term}_2)\)</span> is the co-occurrence probability of both terms and <span class="math">\(Pr(\text{term}_1)Pr(\text{term}_2)\)</span> is the probability that the two co-occur if the are statistically independent.</p>
<p>The final formula is:</p>
<div class="math">
\[
\text{SO} = \text{PMI}(\text{phrase},\text{&quot;excellent&quot;}) - \text{PMI}(\text{phrase},\text{&quot;poor&quot;})
\]</div>
<p>There are other methods to calculate this, such as the following based on hits (number of matching documents):</p>
<div class="math">
\[
\text{SO} = \log_2\left(\frac{\text{hits}(\text{phrase NEAR &quot;excellent&quot;})\text{hits}(\text{&quot;poor&quot;})}{\text{hits}(\text{phrase NEAR &quot;poor&quot;})\text{hits}(\text{&quot;excellent&quot;})}\right)
\]</div>
<p>And the sentiment of a text is computed by averaging the sentiment of all extracted phrases.</p>
<h4 id="lexicon-expansion">Lexicon Expansion</h4>
<p>As we have seen before, lexicons are sets of words that are usually associated with a sentiment. This section explains how the lists are created.</p>
<p>There are several approaches:</p>
<ul>
<li><p><u>Manual Approach</u>: We have to manually populate the lexicon. This is usually combined with an automated approach.</p>
</li>
<li><p><u>Dictionary Based Approach</u>: We provide the initial seed of opinion words, and then we use a lexicon (such as WordNet) to expand the set of word. This is an iterative approach that recursively looks for new words based on the current set.</p>
</li>
<li><p><u>Corpus Based Approach</u>: This is based on syntactic or co-occurrence patterns. It uses a seed list of opinion words to find other opinion words in a large corpus.</p>
<p>This method will use the seed list in combination with linguistic constraints to identify new opinion words. This constraints can be <em>&quot;AND&quot;</em> or similar words, adding new words to our set that should be complementary of our seed set.</p>
</li>
</ul>
<h3 id="aspect-based-opinion-mining">Aspect-Based Opinion Mining</h3>
<p>Opinions are expressed on certain entity aspects, and these aspects are different for each context. For example, in the case of the following camera review:</p>
<div class="math">
\[
\text{&quot;The picture quality of this camera is not great, but the battery life is long&quot;}
\]</div>
<p>The aspects are <em>&quot;Picture Quality&quot;</em> and <em>&quot;Battery&quot;</em>.</p>
<p>In order to recognize these aspects, we need to :</p>
<ol>
<li><u>Mark opinion words and phrases</u>: We need to find the opinion words, such as <em>&quot;Great&quot;</em> in the example.</li>
<li><u>Handle opinion shifters</u>: There are some words that change opinion orientation, such as <em>&quot;No&quot;</em>. If we find this type of words before the opinion words, then we have to mark it as negative.</li>
<li><u>Handle BUT-clauses</u>: In English, the word <em>&quot;but&quot;</em> means contrary, so we must switch the orientation of the opinion before and after the <em>&quot;but&quot;</em> for its opposite.</li>
</ol>
<h3 id="comparative-opinion-mining">Comparative Opinion Mining</h3>
<p>Opinions can be expressed in comparative manner, from here we can extract <strong>comparative expressions</strong> and <strong>superlative expressions</strong>. The first one is represented with the comparative form of an adjective or adverb. In contrast, for the superlative expression we use superlative forms of adjectives or adverbs.</p>
<h3 id="sarcasm">Sarcasm</h3>
<p>In discussions it is common for users to use sarcasm and say the opposite of what they mean. To combat this it is better to take a set of data where sarcasm is tagged, such as tweets with the hashtag <em>&quot;sarcasm&quot;</em> and train a machine learning model.</p>
<p>Even with this processing, it is hard to identify the individual sections of the text that contain sarcasm.</p>
<h2 id="text-summarization">Text Summarization</h2>
<p>The goal of text summarization is to automatically reduce a text to its most important content. It is generally used to generate abstracts or to summarize articles or websites. There are also different types of text summarization:</p>
<ul>
<li>Single document vs multi document</li>
<li>Extractive vs abstractive</li>
<li>Generic vs query-driven</li>
</ul>
<p>This process is composed of 3 main stages:</p>
<ul>
<li><u>Content Selection</u>: Select the sentences to extract</li>
<li><u>Information ordering</u>: Choose the order of the information</li>
<li><u>Sentence realization</u>: Clean up sentences</li>
</ul>
<h3 id="frequency-based-summarization">Frequency-Based Summarization</h3>
<p>This method uses PoS tagging and tokenization to split the text into sentences and then select them based on the frequency of the words.</p>
<h3 id="baseline-single-document-summarization">Baseline Single Document Summarization</h3>
<p>This technique is used to create abstracts out of papers and it is based on filtering out sentences containing frequently occurring words that appear near one another. The algorithm goes as follows:</p>
<ol>
<li><p>Detect the most important words in a text and use only the top N (<em>&quot;WORDS&quot;</em>). During this process we can remove stop words, punctuations and use lemmatization and convert stems to reduce the dimensionality of the text.</p>
</li>
<li><p>For each sentence find clusters of important words that are not far away from each other (<em>&quot;DISTANCE&quot;</em>)</p>
</li>
<li><p>The score of the sentence is the max score of its clusters, and the score of each cluster can be calculated as:</p>
<div class="math">
\[
\text{score} = \frac{|\text{significant words in cluster}|\times |\text{significant words in cluster}|}{\text{|cluster words|}}
\]</div>
</li>
<li><p>Return the top sentences</p>
</li>
</ol>
<h2 id="text-models">Text Models</h2>
<p>We have a wide selection of <strong>information retrieval models</strong>. This type of models specify how a document and a query are represented and how the relevance of a document to a user query is defined. There are some common characteristic among all of them:</p>
<ul>
<li><p><strong>Bag of Words (BoW)</strong>: A document or a query is represented as a bag of words</p>
</li>
<li><p><strong>Vocabulary</strong>: It is a set of distinct words/terms for the collection of documents:</p>
<div class="math">
\[
V = \{t_1,t_2,\dots,t_{|V|}\}
\]</div>
</li>
<li><p><strong>Term Vector</strong>: It represents each document as a vector of weights <span class="math">\(w_{ij}\)</span></p>
<div class="math">
\[
d_j = (w_{1j},\dots,w_{|V|j})
\]</div>
</li>
</ul>
<h3 id="boolean-model">Boolean Model</h3>
<p>It is the simplest model and it is based on Boolean algebra. It represents the documents as a term vector where the weights represent the presence or absence of the term. The queries are precise semantic using boolean operators such as <code>AND,OR,NOT</code>.</p>
<p>For retrieval, only exact matches are considered, the document will either be relevant or not. This can lead to poor results.</p>
<h3 id="vector-space-model">Vector Space Model</h3>
<p>this is one of the most widely used models. It uses any number to represent the weight in the term vector. There are some variations of the weighting schema, but the most common one is <strong>TF-IDF</strong>.</p>
<p>This schema takes into account the <strong>term frequency</strong>, counting how many times the term appears in the document and normalizes it. It also takes into consideration <strong>inverse document frequency</strong>, measuring how common a word is among all documents.</p>
<p>Then we can create the matrix as:</p>
<div class="math">
\[
\text{TF-IDF} = \text{TF} \times \text{IDF}
\]</div>
<h3 id="simple-scoring">Simple Scoring</h3>
<p>We can measure the overlap of two sets to calculate the score of the results of the query. This is called the <strong>Jaccard Coefficient</strong> and it assigns a number from 0 to 1. The formula is as follows:</p>
<div class="math">
\[
\text{jaccard}(\text{docA},\text{docB}) = \frac{|\text{docA} \cap \text{docB}|}{|\text{docA} \cup \text{docB}|}
\]</div>
<p>The problem with this approach is that is doesn't consider term frequency and that it gives more important to more frequent terms, that are usually less informative.</p>
<h3 id="euclidian-based-proximity-measure">Euclidian Based Proximity Measure</h3>
<p>Euclidean distance represents the query and document in a vector space model and computes the distance between them in a multi-dimensional space. Given tow vectors with <span class="math">\(n\)</span> dimensionality:</p>
<div class="math">
\[
\text{d}(p,q) = \sqrt{\sum_{i=1}^{n} (q_i - p_i)^2}
\]</div>
<p>This also has its own problems, mostly due to the fact that if a query term occurs more times in the documents, the distance will be larger, although the distribution of terms are similar.</p>
<h3 id="cosine-based-proximity-measure">Cosine Based Proximity Measure</h3>
<p>This method is similar to the previous one, as it represents the documents in a vector space. The difference is that here we are using the angle instead of the distance between 2 vectors. It can be calculated as:</p>
<div class="math">
\[
\text{similarity}(Q,D) = \frac{Q \cdot D}{||Q||||D||} = \frac{\sum_{i=1}^n Q_i \times B_i}{\sqrt{\sum_{i=1}^n (D_i)^2}  \times \sqrt{\sum_{i=1}^n (Q_i)^2}}
\]</div>
<h2 id="word-embeddings">Word Embeddings</h2>
<p>Word embeddings are based on distributional hypothesis, words that occur in similar contexts tend to have similar meaning. This modeling technique is sued for mapping words to vectors of real numbers. It allows words with similar meanings to have a similar representation and it can be generated with various methods, such as neural networks, co-occurrence matrix, etc.</p>
<p><strong>Word2Vec</strong> is the most popular tool to learn word embeddings and it uses a shallow neural network. It contains a Continuous bag-of-words used to predict the current word based on the context, and continuous skip-gram, taht predicts teh surrounding words given the current word.</p>

</body>
</html>