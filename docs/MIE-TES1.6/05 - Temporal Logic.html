<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>05 - Temporal Logic</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://raw.githubusercontent.com/slashfoo/lmweb/master/style/latinmodern-mono-light.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="temporal-logic">Temporal Logic</h1>
<p>How do we know that a given automaton will fulfill the specifications of a given system? We want to check this out in an automatic way if possible. For this we will use <strong>temporal specification</strong> and <strong>properties</strong> that we saw on a previous class.</p>
<p>We will simplify the automaton to get it as simple as possible, so we will only keep the <strong>transition system</strong>, which is:</p>
<ul>
<li>The set of states <span class="math inline">\(S\)</span></li>
<li>The set of initial states <span class="math inline">\(S_0\)</span></li>
<li>The transition relation <span class="math inline">\(R \subseteq S \times S\)</span></li>
</ul>
<h3 id="transition-systems">Transition Systems</h3>
<p>Given a transition system <span class="math inline">\((S,S_0,R)\)</span>, we will define a <strong>path</strong> as a list of states that can be connected using the transition relation <span class="math inline">\(R\)</span>. Formally, this is translated to: <span class="math display">\[
(s_0,s_1,\dots) \in \Sigma_S / s_0 \in S_0, (s_0,s_1) \in R, (s1,s_2)\in R, \dots
\]</span> And we will use the following notation: <span class="math display">\[
s_0 \rightarrow s_1 \rightarrow \dots
\]</span></p>
<h3 id="proprieties-of-states">Proprieties of States</h3>
<p>A <strong>state property</strong> is a name that denotes a subset of the states <span class="math inline">\(S\)</span>. For example, if our states are the temperatures, we can have a property <em>hot</em> that represents the following states (temperatures): <span class="math display">\[
\text{hot} : \{x\in S/s &gt; 30^o\}
\]</span> We also have a function called <strong>interpretation</strong> that matches each state property to a set of states. If we keep using our example: <span class="math display">\[
\mathcal I(\text{hot}) = \{x\in S/s &gt; 30^o\}
\]</span> A state property <span class="math inline">\(p\)</span> holds on a state <span class="math inline">\(s\)</span> if <span class="math inline">\(s\in\mathcal I(p)\)</span>. We will use the following notation: <span class="math display">\[
s\models p
\]</span></p>
<h3 id="temporal-specification">Temporal Specification</h3>
<p>For a path <span class="math inline">\(\pi\)</span> of the form <span class="math inline">\((s_0,s_1,\dots)\)</span> , we denote by:</p>
<ul>
<li><span class="math inline">\(\pi^i\)</span>, the <span class="math inline">\(i^{th}\)</span> suffix of <span class="math inline">\(\pi\)</span>. This will return the path <span class="math inline">\((s_i,s_{i+1}, \dots)\)</span></li>
<li><span class="math inline">\(\pi(i)\)</span> is the element <span class="math inline">\(s_i\)</span>.</li>
</ul>
<p>We say that a state property <span class="math inline">\(p\)</span> holds on a path <span class="math inline">\(\pi\)</span> if it holds on the first element of the path: <span class="math display">\[
\pi \models p \iff \pi(0) \models p
\]</span> We call <strong>counter-example</strong> of a property <span class="math inline">\(p\)</span> to a path that doesn’t hold that property: <span class="math display">\[
\pi \not\models p
\]</span></p>
<h4 id="operators">Operators</h4>
<p>We have different operators in temporal logic:</p>
<ul>
<li><p><span class="math inline">\(\pi \models Xp\)</span>: The property <span class="math inline">\(p\)</span> will hold on the next elements in the path: <span class="math display">\[
\pi \models Xp \iff \pi^1\models p \iff \pi(1) \models p
\]</span></p></li>
<li><p><span class="math inline">\(\pi \models Fp\)</span>: The property <span class="math inline">\(p\)</span> will eventually hold for some element in the path: <span class="math display">\[
\pi \models Fp \iff \exists k \in \mathbb{N}_0 / \pi^k\models p
\]</span></p></li>
<li><p><span class="math inline">\(\pi \models Gp\)</span>: The Property <span class="math inline">\(p\)</span> will always hold for all items of the path: <span class="math display">\[
\pi \models Gp \iff  \forall k \in \mathbb{N}_0 / \pi^k \models p
\]</span></p></li>
<li><p><span class="math inline">\(\pi \models pUq\)</span>: The property <span class="math inline">\(q\)</span> will hold until the property <span class="math inline">\(p\)</span> holds: <span class="math display">\[
\pi \models pUq \iff \exists i / \pi^i \models q \land \forall j &lt; i, \pi^j \models p
\]</span></p></li>
<li><p><span class="math inline">\(\pi \models pRq\)</span>: The property <span class="math inline">\(p\)</span> will hold as long as the property <span class="math inline">\(q\)</span> doesn’t hold: <span class="math display">\[
\forall j \in \mathbb{N}_0 \text{ if } \forall i &lt; j \pi^i \not\models p \text{ then } \pi^i \models q 
\]</span></p></li>
</ul>
<p>We can also join and merge these operators and use regular Boolean operators to generate <strong>Linear Temporal Logic</strong> (LTL). Here every state property is an LTL formula, and we use the following operator priority:</p>
<ol type="1">
<li><span class="math inline">\(\neg,X,F,G\)</span></li>
<li><span class="math inline">\(U,R\)</span></li>
<li><span class="math inline">\(\land,\lor,\Rightarrow, \Leftrightarrow\)</span></li>
</ol>
<p>For the <span class="math inline">\(U, R\)</span> operators, we will use right-associativity.</p>
<p>We can also use the following list of equivalences</p>
<p><img src="Resources/05 - Temporal Logic/image-20201108191530729.png" alt="image-20201108191530729" style="zoom:100%;" /></p>
<figure>
<img src="Resources/05%20-%20Temporal%20Logic/image-20201108191544702.png" alt="image-20201108191544702" /><figcaption aria-hidden="true">image-20201108191544702</figcaption>
</figure>
<figure>
<img src="Resources/05%20-%20Temporal%20Logic/image-20201108191544702.png" alt="image-20201108191544702" /><figcaption aria-hidden="true">image-20201108191544702</figcaption>
</figure>
<h3 id="properties-of-transition-systems">Properties of Transition Systems</h3>
<p><span class="math display">\[
(S,S_0,R) \models p \iff \forall \pi \in (S,S_0,R), \pi \models p
\]</span></p>
<p>Because of this, we can say that: <span class="math display">\[
(S,S_0,R) \models \neg p \not\equiv (S,S_0,R) \not\models p
\]</span> If the transition system is obvious, then we can write: <span class="math display">\[
\models p
\]</span></p>
</body>
</html>
