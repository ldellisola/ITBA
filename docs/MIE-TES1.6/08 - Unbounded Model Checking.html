<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>08 - Unbounded Model Checking</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://raw.githubusercontent.com/slashfoo/lmweb/master/style/latinmodern-mono-light.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="unbounded-model-checking">Unbounded Model Checking</h1>
<p>Before we learnt how to test our models in bounded time, but we have transition systems with infinitely many paths of infinite length, if we want to be certain that a model fulfills its specification we need to validate them.</p>
<p>To solve this problem we are introducing Unbounded Model Checking, a method for proving LTL properties.</p>
<p>One tool that we are using now are <strong>safety certificates</strong>. They are a set of states <span class="math inline">\(V\)</span> that comply with:</p>
<ul>
<li><span class="math inline">\(V\)</span> contains every initial state : <span class="math inline">\(S_0 \subseteq V\)</span></li>
<li>No transition leads out of <span class="math inline">\(V\)</span>: <span class="math inline">\(\text{Post}_R(V) \subseteq V\)</span></li>
<li><span class="math inline">\(V\)</span> contains only safe states: <span class="math inline">\(V \subseteq \mathcal I(\text{ok})\)</span></li>
</ul>
<p>where <span class="math inline">\(\text{Post}_R(V) = \{x&#39;/x \in V, (x,x&#39;) \in R\}\)</span>.</p>
<p>These conditions are know as <strong>safety verification conditions</strong>. And the first two conditions are called <strong>inductivity conditions</strong>. The inductivity conditions implies that <span class="math inline">\(V\)</span> contains the <strong>reach set</strong>, the set that contains all the reachable states: <span class="math display">\[
\{\pi(k)/ \pi \text{ path},k \in \mathbb{N}_0\} \subseteq V
\]</span> The third condition helps us determine that all reachable states are safe.</p>
<p>An arbitrary set that contains all reachable states, meaning a superset of the reach set is called <strong>inductive variant</strong>. When talking about transition systems, we refer to the <strong>trivial indictive invariant</strong> as the set that contains all the states of the system.</p>
<h2 id="how-to-check-g-conditions">How to Check <span class="math inline">\(G\)</span> Conditions</h2>
<p>Checking for small sets is not a problem as most times we can brute force it or guess <span class="math inline">\(V\)</span> from an expert estimation or from the documentation, but this strategy is not valid for large or infinite transition systems.</p>
<p>In those cases we are going to implement <strong>symbolic checking of safety verification conditions</strong>. For this ne are assuming we have the transition system, <span class="math inline">\(V\)</span> and <span class="math inline">\(\text{ok}\)</span> given symbolically, using logical formulas: <span class="math display">\[
(S,\{x/S_0(x)\},\{(x,x&#39;)/R(x,x&#39;)\}), \{x/\text{ok}(x)\}, \{x/V(x)\}
\]</span> We can now substitute them in our 3 safety verification conditions:</p>
<ul>
<li><span class="math inline">\(S_0 \subseteq V\)</span></li>
<li><span class="math inline">\(\{x&#39;/x\in V, (x,x&#39;) \in R\} \subseteq V\)</span></li>
<li><span class="math inline">\(V \subseteq \mathcal I (\text{ok})\)</span></li>
</ul>
<p>We can also simplify those conditions into predicate logical formulas:</p>
<ul>
<li><span class="math inline">\(\forall x. S_0(x) \implies V(x)\)</span></li>
<li><span class="math inline">\(\forall x \forall x&#39;. [V(x) \land R(x,x&#39;)] \implies V(x&#39;)\)</span></li>
<li><span class="math inline">\(\forall x. V (x) \implies \text{ok}(x)\)</span></li>
</ul>
<p>Now we need to prove this 3 conditions, but SAT solvers don’t prove, they only check satisfiability. In order to prove them we need to check the satisfiability of the negation of the conditions:</p>
<ul>
<li><span class="math inline">\(\neg [\forall x. S_0(x) \implies V(x)]\)</span></li>
<li><span class="math inline">\(\neg [\forall x \forall x&#39;. [V(x) \land R(x,x&#39;)] \implies V(x&#39;)]\)</span></li>
<li><span class="math inline">\(\neg [\forall x. V (x) \implies \text{ok}(x)]\)</span></li>
</ul>
<h3 id="safety-certificates">Safety Certificates</h3>
<p>Even after that, we do not have the safety certificates yet. In <strong>finite cases</strong> we can view the transition relation as directed graph. Here we can apply <strong>depth first-search</strong>:</p>
<pre class="pseudocode"><code>input: t // finite path with all the states in V
output: False or True

serch(t,V):
    if last(t) in V then:
        return True
    else if last(t) not in I(ok) then:
        return False
    else:
        V.insert(last(t))
        return for all s :  not R(last(t),s) or search(ts,V)</code></pre>
<p>Where if the algorithm return <span class="math inline">\(\bot\)</span> it means that <span class="math inline">\(\not \models G\text{ok}\)</span>, else it says that every states that can be reached from <code>last(t)</code> without reaching a state in <span class="math inline">\(V^{in}\)</span> is in <span class="math inline">\(V\)</span>.</p>
<p>In order for this algorithm to function properly, we wrap in other code to return either False or the reach set (a safety certificate):</p>
<pre class="pseudocode"><code>V = {}
if for all s in S0: search(s,V) then:
    return V
else:
    return False</code></pre>
<p>Using DFS tends to have low memory requirements, but it has some drawbacks:</p>
<ul>
<li>Resulting counter examples tend to be too long</li>
<li>The algorithm may get lost on long, useless paths</li>
<li>It does not work for systems with infinite states.</li>
</ul>
<p>Using <strong>breadth-first search</strong> solves all those problems, but it has high memory requirements, making them not practical for systems with large or infinite states.</p>
<p>Our approach is called <strong>Best-First Search</strong> (also known as <strong>directed model checking</strong>), it is useful in cases where we have good heuristics and the goal is mainly to find counter examples.</p>
<p>A different approach is a <strong>set based algorithm</strong>.:</p>
<pre class="pseudocode"><code>V = S0
while exists transition(x,xp): x in V and xp not in V:
    V = V union Post(V)
return V</code></pre>
<p>If the resulting set is included in <span class="math inline">\(\mathcal I(\text{ok})\)</span>, then <span class="math inline">\(V\)</span> fulfills the verification conditions.</p>
<p>This algorithm still has some problems though, as it can’t terminate when working with infinite systems, general slow convergence and problems running on complex sets.</p>
<p>Because of this, in practice we use a modification of this algorithm that uses supersets:</p>
<pre class="pseudocode"><code>V = supersetOf(S0)
while exists transition(x,xp): x in V and xp not in V:
    V = supersetOf(V union Post(V))
return V</code></pre>
<p>This new algorithm conserves the same properties as the one before but now the resulting set <span class="math inline">\(V\)</span> is a superset of the reach set.</p>
<p>This creation of a super set can troublesome though:</p>
<ul>
<li>If we overapproximate too much, it might result in violation of <span class="math inline">\(V \subseteq \mathcal I(\text{ok})\)</span></li>
<li>If we overapproximate too little, it might result in termination problems or the set representation blows up</li>
</ul>
<h4 id="backward-computation">Backward Computation</h4>
<p>Instead of looking for a set that fulfills the safety verification conditions, we can also compute its complement, a set of states that leads to an unsafe state, also known as <strong>backward reach set</strong>.</p>
<p>All the algorithms we’ve seen on this lecture can be used to calculate this set if we use a modified version of their transition system: <span class="math display">\[
(S,S_0^-,R^-)
\]</span> where: <span class="math display">\[
S_0^- = S \setminus \mathcal I(\text{ok}) = \{s/s \models \neg ok\}\\
R^- = \{(x&#39;,x) | (x,x&#39;)\in R\}
\]</span> And we are going to check for: <span class="math display">\[
\models G \neg \text{ok}^-
\]</span> Where <span class="math inline">\(\mathcal I(\text{ok}^-) = S_0\)</span></p>
<h2 id="how-to-check-f-conditions">How to Check <span class="math inline">\(F\)</span> Conditions</h2>
<p>In order to obtain a Safety Certificate we need to convert our model with a topological sort into a strict linear order on all states. After the topological sort, we cannot have transitions that “go back” to a state that is before.</p>
<p>To avoid this we can usually remove transitions that go back and rearrange the topological sort. For example, if we have the following model:</p>
<p><img src="Resources/08 - Unbounded Model Checking/image-20201127151518287.png" alt="image-20201127151518287" style="zoom:67%;" /></p>
<p>We can see that if we were to create a topological sort, it would have some transitions that go back, for example <span class="math inline">\(C\rarr D\)</span>:</p>
<p><img src="Resources/08 - Unbounded Model Checking/image-20201127151744804.png" alt="image-20201127151744804" style="zoom:67%;" /></p>
<p>If we remove that transition, we can rearrange the topological sort into a better solution:</p>
<p><img src="Resources/08 - Unbounded Model Checking/image-20201127152447386.png" alt="image-20201127152447386" style="zoom:67%;" /></p>
<p>In this case, the certificate is defined as a pair <span class="math inline">\((V,\succ)\)</span> where <span class="math inline">\(\succ\)</span> is a struct linear order on <span class="math inline">\(V\)</span> such that:</p>
<ul>
<li><span class="math inline">\(S_0 \subseteq V \subseteq S\)</span></li>
<li><span class="math inline">\(\forall (s,s&#39;) \in R, s \in V, s&#39;\not \in V \implies s&#39; \in \mathcal I(\text{goal})\)</span></li>
<li><span class="math inline">\(\forall (s,s&#39;) \in (R \cap V \times V), s \succ s&#39;\)</span></li>
</ul>
<p>Here we also have a few algorithms to solve this problem, for example <strong>Depth-First Search</strong>:</p>
<pre class="pseudocode"><code>input: finite path t, list V
output: True or False // Depeding in the property holds

search(t,V):
    if last(t) not in I(goal) and Exists 0 &lt;= i &lt;= |t|-2 t(i) == last(t) then:
        return False
    else if last(t) in I(goal) or last(t) in V then:
        return True
    else:
        r = for all s  not R(last(t),s) or search(ts,V)
        V.insert(last(t))
        return r</code></pre>
<p>Similar to the other algorithms, we are going to wrap this one in some code to return either false or the set <span class="math inline">\(V\)</span>:</p>
<pre class="pseudocode"><code>V = {}
if for all s in S0, search(s,V) then:
    return V
else:
    return False</code></pre>
<h2 id="how-to-check-r-conditions">How to Check <span class="math inline">\(R\)</span> Conditions</h2>
<p>To check for this formula, we can use the following equivalence: <span class="math display">\[
G\phi \equiv \bot R\phi
\]</span></p>
</body>
</html>
