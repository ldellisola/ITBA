<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>06 - Normalizacion.md</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        html {
    overflow-x: initial !important;
}

:root {
    --bg-color: #ffffff;
    --text-color: #333333;
    --select-text-bg-color: #B5D6FC;
    --select-text-font-color: auto;
    --monospace: "Lucida Console", Consolas, "Courier", monospace;
}

html {
    font-size: 14px;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
}

body {
    margin: 5%;
    padding: 0px;
    height: auto;
    bottom: 0px;
    top: 0px;
    left: 0px;
    right: 0px;
    font-size: 1rem;
    line-height: 1.42857;
    overflow-x: hidden;
    background: inherit;
    tab-size: 4;
    max-width: 100%;
}

iframe {
    margin: auto;
}

a.url {
    word-break: break-all;
}

a:active, a:hover {
    outline: 0px;
}

.in-text-selection, ::selection {
    text-shadow: none;
    background: var(--select-text-bg-color);
    color: var(--select-text-font-color);
}

#write {
    margin: 0px auto;
    height: auto;
    width: inherit;
    word-break: normal;
    overflow-wrap: break-word;
    position: relative;
    white-space: normal;
    overflow-x: visible;
    padding-top: 40px;
}

#write.first-line-indent p {
    text-indent: 2em;
}

#write.first-line-indent li p, #write.first-line-indent p * {
    text-indent: 0px;
}

#write.first-line-indent li {
    margin-left: 2em;
}

.for-image #write {
    padding-left: 8px;
    padding-right: 8px;
}

body.typora-export {
    padding-left: 30px;
    padding-right: 30px;
}

.typora-export .footnote-line, .typora-export li, .typora-export p {
    white-space: pre-wrap;
}

@media screen and (max-width: 500px) {
    body.typora-export {
        padding-left: 0px;
        padding-right: 0px;
    }

    #write {
        padding-left: 20px;
        padding-right: 20px;
    }

    .CodeMirror-sizer {
        margin-left: 0px !important;
    }

    .CodeMirror-gutters {
        display: none !important;
    }
}

#write li > figure:last-child {
    margin-bottom: 0.5rem;
}

#write ol, #write ul {
    position: relative;
}

img {
    max-width: 100%;
    vertical-align: middle;
}

button, input, select, textarea {
    color: inherit;
    font: inherit;
}

input[type="checkbox"], input[type="radio"] {
    line-height: normal;
    padding: 0px;
}

*, ::after, ::before {
    box-sizing: border-box;
}

#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre {
    width: inherit;
}

#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p {
    position: relative;
}

p {
    line-height: inherit;
}

h1, h2, h3, h4, h5, h6 {
    break-after: avoid-page;
    break-inside: avoid;
    orphans: 2;
}

p {
    orphans: 4;
}

h1 {
    font-size: 2rem;
    text-align: center
}

h2 {
    font-size: 1.8rem;
}

h3 {
    font-size: 1.6rem;
}

h4 {
    font-size: 1.4rem;
}

h5 {
    font-size: 1.2rem;
}

h6 {
    font-size: 1rem;
}

.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p {
    margin-top: 1rem;
    margin-bottom: 1rem;
}

.hidden {
    display: none;
}

.md-blockmeta {
    color: rgb(204, 204, 204);
    font-weight: 700;
    font-style: italic;
}

a {
    cursor: pointer;
}

sup.md-footnote {
    padding: 2px 4px;
    background-color: rgba(238, 238, 238, 0.7);
    color: rgb(85, 85, 85);
    border-radius: 4px;
    cursor: pointer;
}

sup.md-footnote a, sup.md-footnote a:hover {
    color: inherit;
    text-transform: inherit;
    text-decoration: inherit;
}

#write input[type="checkbox"] {
    cursor: pointer;
    width: inherit;
    height: inherit;
}

figure {
    overflow-x: auto;
    margin: 1.2em 0px;
    max-width: calc(100% + 16px);
    padding: 0px;
}

figure > table {
    margin: 0px !important;
}

tr {
    break-inside: avoid;
    break-after: auto;
}

thead {
    display: table-header-group;
}

table {
    border-collapse: collapse;
    border-spacing: 0px;
    width: 100%;
    overflow: auto;
    break-inside: auto;
    text-align: left;
}

table.md-table td {
    min-width: 32px;
}

.CodeMirror-gutters {
    border-right: 0px;
    background-color: inherit;
}

.CodeMirror-linenumber {
    user-select: none;
}

.CodeMirror {
    text-align: left;
}

.CodeMirror-placeholder {
    opacity: 0.3;
}

.CodeMirror pre {
    padding: 0px 4px;
}

.CodeMirror-lines {
    padding: 0px;
}

div.hr:focus {
    cursor: none;
}

#write pre {
    white-space: pre-wrap;
}

#write.fences-no-line-wrapping pre {
    white-space: pre;
}

#write pre.ty-contain-cm {
    white-space: normal;
}

.CodeMirror-gutters {
    margin-right: 4px;
}

.md-fences {
    font-size: 0.9rem;
    display: block;
    break-inside: avoid;
    text-align: left;
    overflow: visible;
    white-space: pre;
    background: inherit;
    position: relative !important;
}

.md-diagram-panel {
    width: 100%;
    margin-top: 10px;
    text-align: center;
    padding-top: 0px;
    padding-bottom: 8px;
    overflow-x: auto;
}

#write .md-fences.mock-cm {
    white-space: pre-wrap;
}

.md-fences.md-fences-with-lineno {
    padding-left: 0px;
}

#write.fences-no-line-wrapping .md-fences.mock-cm {
    white-space: pre;
    overflow-x: auto;
}

.md-fences.mock-cm.md-fences-with-lineno {
    padding-left: 8px;
}

.CodeMirror-line, twitterwidget {
    break-inside: avoid;
}

.footnotes {
    opacity: 0.8;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-bottom: 1em;
}

.footnotes + .footnotes {
    margin-top: 0px;
}

.md-reset {
    margin: 0px;
    padding: 0px;
    border: 0px;
    outline: 0px;
    vertical-align: top;
    background: 0px 0px;
    text-decoration: none;
    text-shadow: none;
    float: none;
    position: static;
    width: auto;
    height: auto;
    white-space: nowrap;
    cursor: inherit;
    -webkit-tap-highlight-color: transparent;
    line-height: normal;
    font-weight: 400;
    text-align: left;
    box-sizing: content-box;
    direction: ltr;
}

li div {
    padding-top: 0px;
}

blockquote {
    margin: 1rem 0px;
}

li .mathjax-block, li p {
    margin: 0.5rem 0px;
}

li {
    margin: 0px;
    position: relative;
}

blockquote > :last-child {
    margin-bottom: 0px;
}

blockquote > :first-child, li > :first-child {
    margin-top: 0px;
}

.footnotes-area {
    color: rgb(136, 136, 136);
    margin-top: 0.714rem;
    padding-bottom: 0.143rem;
    white-space: normal;
}

#write .footnote-line {
    white-space: pre-wrap;
}

@media print {
    body, html {
        border: 1px solid transparent;
        height: 99%;
        break-after: avoid;
        break-before: avoid;
    }

    #write {
        margin-top: 0px;
        padding-top: 0px;
        border-color: transparent !important;
    }

    .typora-export * {
        -webkit-print-color-adjust: exact;
    }

    html.blink-to-pdf {
        font-size: 13px;
    }

    .typora-export #write {
        padding-left: 32px;
        padding-right: 32px;
        padding-bottom: 0px;
        break-after: avoid;
    }

    .typora-export #write::after {
        height: 0px;
    }
}

.footnote-line {
    margin-top: 0.714em;
    font-size: 0.7em;
}

a img, img a {
    cursor: pointer;
}

pre.md-meta-block {
    font-size: 0.8rem;
    min-height: 0.8rem;
    white-space: pre-wrap;
    background: rgb(204, 204, 204);
    display: block;
    overflow-x: hidden;
}

p > .md-image:only-child:not(.md-img-error) img, p > img:only-child {
    display: block;
    margin: auto;
}

p > .md-image:only-child {
    display: inline-block;
    width: 100%;
}

#write .MathJax_Display {
    margin: 0.8em 0px 0px;
}

.md-math-block {
    width: 100%;
}

.md-math-block:not(:empty)::after {
    display: none;
}

[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus {
    outline: 0px;
    box-shadow: none;
}

.md-task-list-item {
    position: relative;
    list-style-type: none;
}

.task-list-item.md-task-list-item {
    padding-left: 0px;
}

.md-task-list-item > input {
    position: absolute;
    top: 0px;
    left: 0px;
    margin-left: -1.2em;
    margin-top: calc(1em - 10px);
    border: none;
}

.math {
    font-size: 1rem;
}

.md-toc {
    min-height: 3.58rem;
    position: relative;
    font-size: 0.9rem;
    border-radius: 10px;
}

.md-toc-content {
    position: relative;
    margin-left: 0px;
}

.md-toc-content::after, .md-toc::after {
    display: none;
}

.md-toc-item {
    display: block;
    color: rgb(65, 131, 196);
}

.md-toc-item a {
    text-decoration: none;
}

.md-toc-inner:hover {
    text-decoration: underline;
}

.md-toc-inner {
    display: inline-block;
    cursor: pointer;
}

.md-toc-h1 .md-toc-inner {
    margin-left: 0px;
    font-weight: 700;
}

.md-toc-h2 .md-toc-inner {
    margin-left: 2em;
}

.md-toc-h3 .md-toc-inner {
    margin-left: 4em;
}

.md-toc-h4 .md-toc-inner {
    margin-left: 6em;
}

.md-toc-h5 .md-toc-inner {
    margin-left: 8em;
}

.md-toc-h6 .md-toc-inner {
    margin-left: 10em;
}

@media screen and (max-width: 48em) {
    .md-toc-h3 .md-toc-inner {
        margin-left: 3.5em;
    }

    .md-toc-h4 .md-toc-inner {
        margin-left: 5em;
    }

    .md-toc-h5 .md-toc-inner {
        margin-left: 6.5em;
    }

    .md-toc-h6 .md-toc-inner {
        margin-left: 8em;
    }
}

a.md-toc-inner {
    font-size: inherit;
    font-style: inherit;
    font-weight: inherit;
    line-height: inherit;
}

.footnote-line a:not(.reversefootnote) {
    color: inherit;
}

.md-attr {
    display: none;
}

.md-fn-count::after {
    content: ".";
}

code, pre, samp, tt {
    font-family: var(--monospace);
}

kbd {
    margin: 0px 0.1em;
    padding: 0.1em 0.6em;
    font-size: 0.8em;
    color: rgb(36, 39, 41);
    background: rgb(255, 255, 255);
    border: 1px solid rgb(173, 179, 185);
    border-radius: 3px;
    box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset;
    white-space: nowrap;
    vertical-align: middle;
}

.md-comment {
    color: rgb(162, 127, 3);
    opacity: 0.8;
    font-family: var(--monospace);
}

code {
    text-align: left;
    vertical-align: initial;
}

a.md-print-anchor {
    white-space: pre !important;
    border-width: initial !important;
    border-style: none !important;
    border-color: initial !important;
    display: inline-block !important;
    position: absolute !important;
    width: 1px !important;
    right: 0px !important;
    outline: 0px !important;
    background: 0px 0px !important;
    text-decoration: initial !important;
    text-shadow: initial !important;
}

.md-inline-math .MathJax_SVG .noError {
    display: none !important;
}

.html-for-mac .inline-math-svg .MathJax_SVG {
    vertical-align: 0.2px;
}

.md-math-block .MathJax_SVG_Display {
    text-align: center;
    margin: 0px;
    position: relative;
    text-indent: 0px;
    max-width: none;
    max-height: none;
    min-height: 0px;
    min-width: 100%;
    width: auto;
    overflow-y: hidden;
    display: block !important;
}

.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display {
    width: auto;
    margin: inherit;
    display: inline-block !important;
}

.MathJax_SVG .MJX-monospace {
    font-family: var(--monospace);
}

.MathJax_SVG .MJX-sans-serif {
    font-family: sans-serif;
}

.MathJax_SVG {
    display: inline;
    font-style: normal;
    font-weight: 400;
    line-height: normal;
    zoom: 90%;
    text-indent: 0px;
    text-align: left;
    text-transform: none;
    letter-spacing: normal;
    word-spacing: normal;
    overflow-wrap: normal;
    white-space: nowrap;
    float: none;
    direction: ltr;
    max-width: none;
    max-height: none;
    min-width: 0px;
    min-height: 0px;
    border: 0px;
    padding: 0px;
    margin: 0px;
}

.MathJax_SVG * {
    transition: none 0s ease 0s;
}

.MathJax_SVG_Display svg {
    vertical-align: middle !important;
    margin-bottom: 0px !important;
    margin-top: 0px !important;
}

.os-windows.monocolor-emoji .md-emoji {
    font-family: "Segoe UI Symbol", sans-serif;
}

.md-diagram-panel > svg {
    max-width: 100%;
}

[lang="flow"] svg, [lang="mermaid"] svg {
    max-width: 100%;
    height: auto;
}

[lang="mermaid"] .node text {
    font-size: 1rem;
}

table tr th {
    border-bottom: 0px;
}

video {
    max-width: 100%;
    display: block;
    margin: 0px auto;
}

iframe {
    max-width: 100%;
    width: 100%;
    border: none;
}

.highlight td, .highlight tr {
    border: 0px;
}

svg[id^="mermaidChart"] {
    line-height: 1em;
}

mark {
    background: rgb(255, 255, 0);
    color: rgb(0, 0, 0);
}

.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong {
    color: inherit;
}

mark .md-meta {
    color: rgb(0, 0, 0);
    opacity: 0.3 !important;
}


.CodeMirror {
    height: auto;
}

.CodeMirror.cm-s-inner {
    background: inherit;
}

.CodeMirror-scroll {
    overflow: auto hidden;
    z-index: 3;
}

.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler {
    background-color: rgb(255, 255, 255);
}

.CodeMirror-gutters {
    border-right: 1px solid rgb(221, 221, 221);
    background: inherit;
    white-space: nowrap;
}

.CodeMirror-linenumber {
    padding: 0px 3px 0px 5px;
    text-align: right;
    color: rgb(153, 153, 153);
}

.cm-s-inner .cm-keyword {
    color: rgb(119, 0, 136);
}

.cm-s-inner .cm-atom, .cm-s-inner.cm-atom {
    color: rgb(34, 17, 153);
}

.cm-s-inner .cm-number {
    color: rgb(17, 102, 68);
}

.cm-s-inner .cm-def {
    color: rgb(0, 0, 255);
}

.cm-s-inner .cm-variable {
    color: rgb(0, 0, 0);
}

.cm-s-inner .cm-variable-2 {
    color: rgb(0, 85, 170);
}

.cm-s-inner .cm-variable-3 {
    color: rgb(0, 136, 85);
}

.cm-s-inner .cm-string {
    color: rgb(170, 17, 17);
}

.cm-s-inner .cm-property {
    color: rgb(0, 0, 0);
}

.cm-s-inner .cm-operator {
    color: rgb(152, 26, 26);
}

.cm-s-inner .cm-comment, .cm-s-inner.cm-comment {
    color: rgb(170, 85, 0);
}

.cm-s-inner .cm-string-2 {
    color: rgb(255, 85, 0);
}

.cm-s-inner .cm-meta {
    color: rgb(85, 85, 85);
}

.cm-s-inner .cm-qualifier {
    color: rgb(85, 85, 85);
}

.cm-s-inner .cm-builtin {
    color: rgb(51, 0, 170);
}

.cm-s-inner .cm-bracket {
    color: rgb(153, 153, 119);
}

.cm-s-inner .cm-tag {
    color: rgb(17, 119, 0);
}

.cm-s-inner .cm-attribute {
    color: rgb(0, 0, 204);
}

.cm-s-inner .cm-header, .cm-s-inner.cm-header {
    color: rgb(0, 0, 255);
}

.cm-s-inner .cm-quote, .cm-s-inner.cm-quote {
    color: rgb(0, 153, 0);
}

.cm-s-inner .cm-hr, .cm-s-inner.cm-hr {
    color: rgb(153, 153, 153);
}

.cm-s-inner .cm-link, .cm-s-inner.cm-link {
    color: rgb(0, 0, 204);
}

.cm-negative {
    color: rgb(221, 68, 68);
}

.cm-positive {
    color: rgb(34, 153, 34);
}

.cm-header, .cm-strong {
    font-weight: 700;
}

.cm-del {
    text-decoration: line-through;
}

.cm-em {
    font-style: italic;
}

.cm-link {
    text-decoration: underline;
}

.cm-error {
    color: red;
}

.cm-invalidchar {
    color: red;
}

.cm-constant {
    color: rgb(38, 139, 210);
}

.cm-defined {
    color: rgb(181, 137, 0);
}

div.CodeMirror span.CodeMirror-matchingbracket {
    color: rgb(0, 255, 0);
}

div.CodeMirror span.CodeMirror-nonmatchingbracket {
    color: rgb(255, 34, 34);
}

.cm-s-inner .CodeMirror-activeline-background {
    background: inherit;
}

.CodeMirror {
    position: relative;
    overflow: hidden;
}

.CodeMirror-scroll {
    height: 100%;
    outline: 0px;
    position: relative;
    box-sizing: content-box;
    background: inherit;
}

.CodeMirror-sizer {
    position: relative;
}

.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar {
    position: absolute;
    z-index: 6;
    display: none;
}

.CodeMirror-vscrollbar {
    right: 0px;
    top: 0px;
    overflow: hidden;
}

.CodeMirror-hscrollbar {
    bottom: 0px;
    left: 0px;
    overflow: hidden;
}

.CodeMirror-scrollbar-filler {
    right: 0px;
    bottom: 0px;
}

.CodeMirror-gutter-filler {
    left: 0px;
    bottom: 0px;
}

.CodeMirror-gutters {
    position: absolute;
    left: 0px;
    top: 0px;
    padding-bottom: 30px;
    z-index: 3;
}

.CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    box-sizing: content-box;
    padding-bottom: 30px;
    margin-bottom: -32px;
    display: inline-block;
}

.CodeMirror-gutter-wrapper {
    position: absolute;
    z-index: 4;
    background: 0px 0px !important;
    border: none !important;
}

.CodeMirror-gutter-background {
    position: absolute;
    top: 0px;
    bottom: 0px;
    z-index: 4;
}

.CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
}

.CodeMirror-lines {
    cursor: text;
}

.CodeMirror pre {
    border-radius: 0px;
    border-width: 0px;
    background: 0px 0px;
    font-family: inherit;
    font-size: inherit;
    margin: 0px;
    white-space: pre;
    overflow-wrap: normal;
    color: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
}

.CodeMirror-wrap pre {
    overflow-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
}

.CodeMirror-code pre {
    border-right: 30px solid transparent;
    width: fit-content;
}

.CodeMirror-wrap .CodeMirror-code pre {
    border-right: none;
    width: auto;
}

.CodeMirror-linebackground {
    position: absolute;
    left: 0px;
    right: 0px;
    top: 0px;
    bottom: 0px;
    z-index: 0;
}

.CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    overflow: auto;
}

.CodeMirror-wrap .CodeMirror-scroll {
    overflow-x: hidden;
}

.CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0px;
    overflow: hidden;
    visibility: hidden;
}

.CodeMirror-measure pre {
    position: static;
}

.CodeMirror div.CodeMirror-cursor {
    position: absolute;
    visibility: hidden;
    border-right: none;
    width: 0px;
}

.CodeMirror div.CodeMirror-cursor {
    visibility: hidden;
}

.CodeMirror-focused div.CodeMirror-cursor {
    visibility: inherit;
}

.cm-searching {
    background: rgba(255, 255, 0, 0.4);
}

@media print {
    .CodeMirror div.CodeMirror-cursor {
        visibility: hidden;
    }
}


:root {
    --side-bar-bg-color: white;
    --window-border: none;
    --search-select-bg-color: #575c61;
    --active-file-bg-color: #f1f4f5;
    --item-hover-bg-color: #f1f4f5;
    --item-hover-text-color: black;
    --control-text-color: #555;
}

@include-when-export url(https://raw.githubusercontent.com/slashfoo/lmweb/master/style/latinmodern-mono-light.css);

html {
    font-size: 12pt;
}

#write {
    font-family: "STIX2Text", "Times New Roman", "serif";
    line-height: 1.5em;
    padding: 10%;
    padding-top: 5%;
}

.file-list-item-summary {
    height: 36px;
}

.file-list-item {
    padding-top: 18px !important;
    padding-bottom: 18px;
}

#sidebar-loading-template.file-list-item {
    padding-top: 0 !important;
}

a, a:visited {
    color: #a00;
}

h1, h2, h3, h4, h5, h6 {
    font-family: inherit;
    line-height: 1.5em;
    margin-bottom: 1em;
    margin-top: 1em;
}

h1 {
    font-size: 2.4em;
}

#write h1 {
    text-align: center;
}

h2 {
    font-size: 1.8em;
}

h3 {
    font-size: 1.4em;
}

h4 {
    font-size: 1.2em;
}

h5 {
    font-size: 1.1em;
}

h6 {
    font-size: 1em;
}

p {
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: justify;
}

pre, code {
    font-family: 'Latin Modern Mono Light', "Latin Modern Mono", monospace !important;
    background-color: #ebebeb;
}

.footnotes {
    display: list-item;
    margin-left: 1em;
}

.md-fences {
    border: 1px solid;
}

.md-fences.md-fences-with-lineno {
    border: none;
}

.CodeMirror-linenumber {
    color: #333;
}

*.in-text-selection,
::selection,
.CodeMirror-selected {
    background: var(--search-select-bg-color);
    color: var(--search-select-text-color) !important;
    text-shadow: none;
}

a.md-toc-inner {
    color: var(--text-color);
}

.cm-s-typora-default .cm-link {
    color: #a00;
    text-decoration: underline;
}

.cm-s-typora-default .cm-header, .cm-s-typora-default .cm-property {
    color: black;
}

#typora-source .CodeMirror-lines {
    -webkit-font-smoothing: auto;
    max-width: 1000px;
}

.md-def-name:before,
.md-def-name:after {
    color: #2d2d2d;
}

sup.md-footnote {
    background-color: initial;
    color: inherit;
}

mark {
    background: #fff387;
}

td, th {
    border: 1px solid;
    padding-left: 1ch;
    padding-right: 1ch;
}

/*table tr[cid]:first-child > td {
    border-top: 3px double;
}*/

th {
    border-bottom: 0;
    padding-top: 2px;
    background: #575c61;
    border-color: #333;
    color: #f3f3f3;
}

pre.md-meta-block {
    border: 1px solid #a2a9b1;
    background-color: #f8f9fa;
    padding: 5px;
    margin-bottom: 1em;
}

.task-list-item input:before {
    content: '\221A';
    display: inline-block;
    width: 1.25rem;
    height: 1.6rem;
    vertical-align: middle;
    text-align: center;
    color: #bbb;
    background-color: inherit;
}

.task-list-item input:checked:before,
.task-list-item input[checked]:before {
    color: inherit;
}

.md-task-list-item > input {
    top: auto;
    margin-left: -1.1em;
    font-size: 1.3em;
    margin-top: 0px;
    -webkit-appearance: none;
}

.md-task-list-item input:before {
    content: '\2610';
    display: inline-block;
    width: 1.25rem;
    height: 1.6rem;
    vertical-align: middle;
    text-align: center;
    color: #bbb;
    background-color: inherit;
}

.md-task-list-item input:checked:before,
.md-task-list-item input[checked]:before {
    color: inherit;
    content: '\2611';
}

.task-list-item {
    padding-left: 1.5em;
}

blockquote {
    font-style: italic;
    padding: 0.25em 24px;
    position: relative;
    color: #383838;
    border-left: 2px solid;
}

#write > blockquote {
    padding: 0.25em 30px;
    margin-left: -32px;
    width: calc(100% + 32px);
}

#write > .md-fences-with-lineno {
    margin-left: -33px;
    color: black;
}

.CodeMirror-linenumber {
    min-width: 25px;
}

.md-header {
    font-size: inherit !important;
}

/*blockquote:before {
    display: block;
    content: "\201C";
    font-size: 80px;
    position: absolute;
    left: -20px;
    top: -20px;
    color: #7a7a7a;
}*/




    </style>
</head>
<body>
<h1 id="teoria-de-normalizacion">Teoría de Normalización</h1>
<p>Una base de datos relacional es un conjunto de esquemas relacionados y sus restricciones. La mala representación de la información produce ciertas anomalías.</p>
<h3 id="anomalias">Anomalías</h3>
<ul>
<li><p><strong>Anomalía de inserción</strong>:</p>
<p>Cuando se carga una entrada que no tiene todos los valores se lo indica con null, entonces hay entradas con muchos valores necesarios en null</p>
</li>
<li><p><strong>Anomalía de Modificación</strong>:</p>
<p>Cuando hay muchas entradas con datos repetidos y hay que actualizar alguno de estos datos, es muy ineficiente ir cambiándolo en todas las entradas donde esta actualmente.</p>
</li>
<li><p><strong>Anomalía de Borrado</strong>:</p>
<p>Similar a la anomalía de inserción. Causa los mismos problemas.</p>
</li>
</ul>
<p><strong>Enfoque sintético</strong>: tomar tablas gigantes y empezar a partirlo en pedacitos.</p>
<p><strong>Enfoque analítico</strong>: consiste en hacer un modelo de entidad/relaciona bien realizado y generar a las tablas. Luego tengo que chequear que en las tablas creadas no haya anomalías.</p>
<p>La teoría de normalización presenta un mecanismo con dos importantes utilidades:</p>
<ul>
<li>Reorganizar viejos sistemas donde no se conocen detalles de la implementación inicial.</li>
<li>Evaluar la calidad de diseño.</li>
</ul>
<h3 id="dependencia-funcional">Dependencia Funcional</h3>
<p>Sea <span class="math">\(X\)</span> e <span class="math">\(Y\)</span> dos conjuntos de atributos de un esquema de relación <span class="math">\(R\)</span>. Se dice que <span class="math">\(X\)</span> determina funcionalmente a <span class="math">\(Y\)</span> o que <span class="math">\(Y\)</span> depende funcionalmente de <span class="math">\(X\)</span> (<span class="math">\(X\rightarrow Y\)</span>), si se cumple:</p>
<div class="math">
\[
\forall t_1,t_2 \in R :(t_1[X] =t_2[X] \Rightarrow t_1[Y] = t_2[Y])
\]</div>
<p>Al conjunto de dependencias funcionales básicas se lo llama <span class="math">\(F\)</span>.</p>
<h5 id="propiedades">Propiedades</h5>
<div class="math">
\[
\text{La dependencia }X\rightarrow Y \text{ es trivial} \Leftrightarrow Y \subseteq X
\]</div>
<h3 id="claves-y-superclaves">Claves y Superclaves</h3>
<p>Podemos utilizar el concepto de dependencia funcional para definir la superclave y clave y de un esquema relación.</p>
<p>Podemos definir a una <u>superclave</u> de la siguiente forma:</p>
<div class="math">
\[
\text{Sea un esquema de relacion $R$, } X \subseteq R \text{ es superclave para } R \text{ si cumple:}\\
\array{
 (1) &amp;&amp; X \rightarrow R &amp;\text{(determina funcionalmente todo el esquema)}
}
\]</div>
<p>De la misma forma, tenemos una nueva definición para la <u>clave</u>:</p>
<div class="math">
\[
\text{Sea un esquema de relacion $R$, } X \subseteq R \text{ es clave para } R \text{ si cumple:}\\
\array{
 (1) &amp;&amp; X \rightarrow R &amp;\text{(es superclave)}\\
 (2) &amp;&amp; \not \exists Y \subset X / Y \rightarrow R &amp; \text{(condicion minimal)}
}
\]</div>
<p>También tenemos una nueva definición. Podemos definir a un <u>atributo primo</u> como un atributo que forma parte de alguna clave.</p>
<h3 id="clausura-de-dependencias-funcionales">Clausura de Dependencias Funcionales</h3>
<p>Denotaremos con <span class="math">\(F\)</span> al <u>conjunto de dependencias funcionales</u> de un esquema de relación <span class="math">\(R\)</span>. Dicho conjunto se obtiene con las dependencias que son semánticamente obvias sobre dicho esquema. Sin embargo, de estas dependencias obvias pueden surgir muchas otras.</p>
<p>Se denomina <u>clausura</u> del conjunto <span class="math">\(F\)</span>, correspondiente a un esquema,  al conjunto que contiene todas las posibles dependencias funcionales de dicho esquema. También se lo puede definir de la siguiente forma:</p>
<div class="math">
\[
\text{Se denomina } F^+ \text{ a la clausura de } F \text{ y es el conjunto de todas las dependencias}\\ \text{ funcionales inferidas logicamente de } F :\\
F^+ = \{X \rightarrow Y / F \mid= X\rightarrow Y\}
\]</div>
<h3 id="axioma-de-armstrong-y-reglas-de-inferencia">Axioma de Armstrong y Reglas de Inferencia</h3>
<p>Sean <span class="math">\(X, Y, Z\)</span> conjuntos de atributos de un esquema de relación <span class="math">\(R\)</span>, los siguientes axiomas constituyen un conjunto:</p>
<ul>
<li><p><strong>Correcto</strong>: Significa que no se pueden derivar dependencias funcionales que no se puedan implicar lógicamente de <span class="math">\(F\)</span>. Al aplicar los axiomas solo se obtienen dependencias funcionales que están en <span class="math">\(F^+\)</span> (No por fuera de <span class="math">\(F^+\)</span>).</p>
<p>En otras palabras: Si <span class="math">\(X\rightarrow Y\)</span> se deriva lógicamente de <span class="math">\(F\)</span> usando axiomas de Armstrong, entonces <span class="math">\(X\rightarrow Y\)</span> vale para toda relación <span class="math">\(R\)</span> en la cual valgan las dependencias funcionales en <span class="math">\(F\)</span>.</p>
</li>
<li><p><strong>Completo</strong>: Significa que al aplicar dichos axiomas se generar todo <span class="math">\(F^+\)</span>.</p>
<p>Si una dependencia funcional de <span class="math">\(X\rightarrow Y\)</span> pertenece a <span class="math">\(F^+\)</span>, entonces puede deducirse usando los axiomas de Armstrong sobre <span class="math">\(F\)</span>.</p>
</li>
</ul>
<p>Los Axiomas de Armstrong son los siguientes:</p>
<ul>
<li><p>Reflexividad:</p>
<div class="math">
\[
Y \subseteq X \Rightarrow X\rightarrow Y
\]</div>
</li>
<li><p>Aumentación:</p>
<div class="math">
\[
X\rightarrow Y \Rightarrow XZ\rightarrow YZ
\]</div>
</li>
<li><p>Transitividad:</p>
<div class="math">
\[
\left .
\array{
  X \rightarrow Y\\
  Y \rightarrow Z
}

\right \}
\Rightarrow 
X \rightarrow Z
\]</div>
</li>
</ul>
<p>Además, a partir de estos axiomas, se pueden obtener las siguientes reglas:</p>
<ul>
<li><p>Unión:</p>
<div class="math">
\[
\left .
\array{
  X \rightarrow Y\\
  X \rightarrow Z
}

\right \}
\Rightarrow 
X \rightarrow YZ
\]</div>
</li>
<li><p>PseudoTransitividad:</p>
<div class="math">
\[
\left .
\array{
  X \rightarrow Y\\
  UY \rightarrow Z
}

\right \}
\Rightarrow 
XU \rightarrow Z
\]</div>
</li>
<li><p>Descomposición:</p>
<div class="math">
\[
X \rightarrow YZ
\Rightarrow 
\left \{
\array{
  X \rightarrow Y\\
  X \rightarrow Z
}

\right .
\]</div>
</li>
</ul>
<p>Para encontrar una clausura <span class="math">\(F^+\)</span> hay que aplicar estas reglas y axiomas a todas las dependencias funcionales de <span class="math">\(F\)</span> hasta que no se encuentren mas. Este problema tiene una dificultad exponencial y es muy costoso.</p>
<p>Existe un problema mas acotado pero igual de útil llamado <u>Pertenencia de una dependencia Funcional</u>:</p>
<div class="math">
\[
\text{Dado un esquema } R \text{ y el conjunto de dependencias funcionales } F \text{. Siempre es posible} \\ \text{ decidir si una dependencia funcional } X\rightarrow Y \text{ con } X \text{ y } Z \text{ atributos de } R \text{, pertenece a }F^+.
\]</div>
<p>Lo interesante de ese problema es que no es necesario calcular <span class="math">\(F^+\)</span> para resolverlo.</p>
<h3 id="clausura-de-atributos">Clausura de Atributos</h3>
<p>En muchos casos se necesita saber si una dependencia funcional <span class="math">\(X \rightarrow B\)</span> pertenece a <span class="math">\(F^+\)</span>. En este caso conviene trabajar con la clausura del conjunto de atributos que se encuentran a la izquierda de la dependencia a investigar y evitar calcular <span class="math">\(F^+\)</span>.</p>
<p>La clausura de atributos se puede definir como:</p>
<div class="math">
\[
\text{Si } X \text{ es un conjunto de atributos de } R \text{, la clausura de } X \text{, denotada como } X^+ \text{, respecto del } \\ \text{conjunto de dependencias } F \text{ de dicho esquema, es el conjunto de atributos} \\ \text{ determinados por } X \text{ a traves de las dependencias de } F^+:\\
X^+:\{ A / X \rightarrow A \in F^+ \}
\]</div>
<p>A continuación vamos a ver un algoritmo de tiempo lineal para calcular <span class="math">\(X^+\)</span>:</p>
<pre><code class="language-pseudocode">X+ = {X}

while( X+ cambie ) {
	for( cada dependencia funcional Y-&gt; X que pertenece a F ) {
		if(Y esta incluido en X+) {
			X+ = X+ union {Z}
		}
	}
}
</code></pre>
<h3 id="proceso-de-normalizacion">Proceso de Normalización</h3>
<p>La normalización de una base de datos consiste en un proceso por el cual los esquemas de relaciona que presentan anomalías se descomponen en esquemas mas peque;os que cumplen con propiedades deseables para el mantenimiento de la misma.</p>
<p>El proceso de normalización consiste en verificar que un esquema de relación cumple con 4 <u>formas</u> llamadas formas normales <strong>primera</strong>, <strong>segunda</strong> y <strong>tercera</strong>. Además existe una forma Codd-Boyce. Estas 4 formas se basan en dependencias funcionales entre atributos.</p>
<p>Sin embargo, la descomposición que introduce toda normalización no garantiza un buen diseño. Para lograrlo se tienen que considerar las siguientes propiedades:</p>
<ul>
<li><strong>No perder información</strong></li>
<li><strong>Preservar Dependencias</strong></li>
</ul>
<h4 id="descomposicion-sin-perdida-de-informacion">Descomposición sin perdida de información</h4>
<p>Cuando un sistema maneja información redundante, puede ser necesario descomponerlo en otros esquemas, pero esta división no puede ser arbitraria.</p>
<div class="math">
\[
\text{El conjunto de subesquemas }R_1, R_2,\dots,R_k \text{ es una descomposicion } \\ \text{sin perdida de informacion } R \text{ si cumple:}\\
\array{
(1) &amp;&amp; R = \bigcup^{k}_{i=1}R_i \\
(2) &amp;&amp; r_1 \Join r_2 \Join \dots \Join r_k = r \text{ donde } r_i = \pi_{R_i}(r)
}
\]</div>
<h4 id="condicion-de-descomposicion-sin-perdida-para-dos-esquemas">Condición de Descomposición sin Perdida para Dos Esquemas</h4>
<p>Si un esquema de relación <span class="math">\(R\)</span> se descompone solo en <span class="math">\(R_1, R_2\)</span>, la descomposición debe realizarse de manera tal que por lo menos una de las siguientes dependencias funcionales pertenezcan a <span class="math">\(F^+\)</span>:</p>
<div class="math">
\[
\array{
	(R_1 \cap R_2) \rightarrow R_1 - R_2 \\
	(R_1 \cap R_2) \rightarrow R_2 - R_1
}
\]</div>
<h4 id="condicion-de-descomposicion-sin-perdida-para-n-esquemas">Condición de Descomposición sin Perdida para N Esquemas</h4>
<p>Para determinar si al descomposición en mas de dos esquemas tienen perdida de información o no hay que usar una matriz especial denominada <u>tableau</u>.</p>
<p>Esta matriz consiste en una matriz bidimensional que tiene una columna por cada atributo del esquema al cual corresponde dicho tableau. Sus filas están compuestas por variables distinguidas (representadas por la letra <em>a</em>, que aparece subindicador con el numero de la columna) y por variables ligadas o no distinguidas (representadas por la letra <em>b</em>, que aparece subindicada con el numero de fila y columna). Cada variable puede aparecer solo en una columna y en una misma columna no puede haber mas de una variable distinguida.</p>
<p>Para poder detectar la perdida de información en una descomposición, se arma un tableau inicial con una fila por cada subesquema <span class="math">\(R_i\)</span>, completando dicha fila de la siguiente forma:</p>
<div class="math">
\[
T(i,j) =

\left \{
\array{
	a_j &amp; \text{Si } R_i \text{ contiene al atributo } A_j	\\
	b_{ij}&amp; \text{Si } R_i \text{ no contiene al atributo} A_j
}
\right .
\]</div>
<p>A partir de la configuración inicial se van haciendo los cambios necesarios para que se cumplan las dependencias funcionales de <span class="math">\(R\)</span>, obteniendo nuevos tableaus equivalentes al inicial.</p>
<p>Para que una descomposición de N esquemas no tenga perdidas, se tiene que cumplir que:</p>
<div class="math">
\[
\text{Si un esquema de relacion } R \text{ se descompone en } R_1, R_2, \dots, R_N \\
\text{esquemas, la descomposicion debe realizarse de manera tal que por lo menos exista } \\ \text{una fila de variables distinguidas en el tableau correspondiente o en uno equivalente}
\]</div>
<h4 id="descomposicion-preservando-dependencias-sin-perdida-de-dfs">Descomposición Preservando Dependencias (Sin perdida de DFs)</h4>
<p>Mediante el método anterior podemos asegurar que no haya perdida de información, pero podemos haber perdido alguna dependencia funcional. Para asegurarse que no se pierdan estas dependencias, hay que seguir la siguiente regla:</p>
<div class="math">
\[
\text{Dado un esquema } R \text{, se dice que no haya perdida de dependencias al descomponerlo } \\ \text{ en } N \text{ esquemas } R_i \text{, si sus clausuras de dependencias funcionales son equivalentes:}\\\\
\ \\
{F'}^+ = F^+ \text{ donde } F' = \bigcup_{i=1}^N \pi_{R_i}(F^+)
\]</div>
<p>Básicamente tengo que hacer unión de todas las <span class="math">\(F_i\)</span> y a partir de esta unión tenes que poder crear todas las dependencias del <span class="math">\(F\)</span> original.</p>
<p>A continuación se puede ver un algoritmo que permite calcular la proyección de <span class="math">\(F^+\)</span> sobre un subesquema de <span class="math">\(R\)</span></p>
<pre><code class="language-pseudocode">F_1 = F
X = R - R_i
while( X != NULL){
	A / A pertenece a X
	X = X - A
	RES = NULL
	for (cada dependencia del tipo Y -&gt; A en F_1){
		for (cada dependencia del tipo AZ -&gt; B en F_1){
			H = YX -&gt; B
			if (H no es trivial){
				RES = RES union { H }
			}
		}
	}
	for (cada dependencia f en F_1){
		if(A esta en f){
			F_1 = F_1 - { f }
		}
	}
	F_1 = F_1 union RES
}
</code></pre>
<h2 id="formas-normales-sobre-dependencias-entre-atributos">Formas Normales sobre Dependencias entre Atributos</h2>
<p>A continuación veremos las condiciones que se deben cumplir para que un esquema cumpla las 4 formas normales que se basan en las dependencias entre atributos</p>
<h4 id="primera-forma-normal-1nf">Primera forma normal (1NF)</h4>
<div class="math">
\[
\text{Un esquema de relacion } R \text{ se encuentra en }\bold{\text{primera forma normal }} \\ \text{si sus atributos son atomicos}
\]</div>
<h4 id="segunda-forma-normal-2nf">Segunda forma normal (2NF)</h4>
<p>Esta forma normal se basa en el concepto de dependencia funcional total. A continuación vamos a definir los conceptos dependencia total y parcial.</p>
<ul>
<li><strong>Dependencia total</strong>:</li>
</ul>
<div class="math">
\[
  \text{Una dependencia } \alpha \rightarrow\beta 
  \text{ es total si } \forall A \in \alpha :(\alpha - \{A\}) \not \rightarrow \beta
\]</div>
<p>En otras palabras, una dependencia <span class="math">\(\alpha \rightarrow \beta\)</span> es total si <span class="math">\(\beta\)</span> no depende funcionalmente de ningún subconjunto de <span class="math">\(\alpha\)</span>.</p>
<ul>
<li><strong>Dependencia parcial</strong>:</li>
</ul>
<div class="math">
\[
  \text{Una dependencia } \alpha \rightarrow\beta 
  \text{ es parcial si } \exists A \in \alpha :(\alpha - \{A\})  \rightarrow \beta
\]</div>
<p>En otras palabras, <span class="math">\(\beta\)</span> depende parcialmente de <span class="math">\(\alpha\)</span> si depende funcionalmente solo de algún subconjunto de <span class="math">\(\alpha\)</span>. Obviamente que <span class="math">\(\alpha \rightarrow \beta\)</span> sea parcial obliga a que <span class="math">\(\alpha\)</span> sea compuesto.</p>
<p>La definición de 2NF es:</p>
<div class="math">
\[
\text{Un esquema de relacion } R \text{ se encuentra en } \bold{\text{segunda forma normal}}  \text{ si no existe } \\ \text{ningun atributo } A  \text{ no primo en } R \text{ que no sea parcialmente dependiente de alguna clave}
\]</div>
<p>Tradicionalmente se decía que un esquema estaba en 2NF si estaba en 1NF y además todo atributo no primo era totalmente dependiente de la clave.</p>
<p><strong>Normalización de un esquema <span class="math">\(R\)</span> en 2NF</strong></p>
<div class="math">
\[
\text{Para normalizar un esquema que viona 2NF hay que quitarle los atributos no primos } \\ \text{ que dependen parcialmente de la clave y formar un nuevo esquema con ellos y la } \\ \text{ porcion de clave de la que dependian}
\]</div>
<h4 id="tercera-forma-normal-3nf">Tercera forma normal (3NF)</h4>
<p>El <strong>recubrimiento minimal</strong> de <span class="math">\(F\)</span>  es un conjunto <span class="math">\(F_m\)</span> de dependencias funcionales que cumple con:</p>
<ul>
<li><span class="math">\(F_m\)</span> es equivalente a <span class="math">\(F\)</span></li>
<li>El lado derecho de cada dependencia funcional de $F_m $es un atributo simple</li>
<li>Ninguna dependencia funcional en $F_m $ contiene atributos redundantes a izquierda</li>
<li>$F_m $ no tiene dependencias funcionales redundantes</li>
</ul>
<p>También vamos a definir a las <strong>dependencias transitivas</strong>:</p>
<div class="math">
\[
\text{Una dependencia } X \rightarrow Y \text{ es transitiva si existe un conjunto de  atributos} \\ Z\text{ no primos para el cual } X \rightarrow Z \text{ y } Z \rightarrow Y
\]</div>
<p>Tradicionalmente se definía como 3NF a aquellos esquemas que estaban en 2NF y que además para todo conjunto de atributos no primos <span class="math">\(\alpha\)</span> se cumplía que <span class="math">\(\alpha\)</span> no depende transitivamente de una clave.</p>
<p>Por otro lado, la definición formal de la <strong>tercera forma normal</strong> es :</p>
<div class="math">
\[
\text{Un esquema de relacion } R \text{ se encuentra en tercera forma normal si para toda} \\ \text{dependencia } \alpha \rightarrow \beta \text{ no trivial de } F^+ \text{ se cumple:}
\\
\array{
	\alpha \text{ es superclave} &amp; \text{o} &amp; \beta \text{ es primo}
}
\]</div>
<p>Para realizar una normalización hacia la tercera forma normal, se deben seguir los siguientes pasos:</p>
<ol>
<li>Hallar <span class="math">\(F_m\)</span>, un recubrimiento minimal de <span class="math">\(F\)</span></li>
<li>Juntar las dependencias que coincidan en su lado izquierdo (aplicar regla de unión)</li>
<li>Para cada <span class="math">\(X \rightarrow Y\)</span> de <span class="math">\(F_m\)</span>, crear una relación con el esquema <span class="math">\(XY\)</span></li>
<li>Eliminar toda relación cuyo esquema sea subconjunto de otro.</li>
<li>Si ninguno de los esquemas creados contiene una clave candidata de <span class="math">\(R\)</span>, agregar un esquema conteniéndola, a los efectos de que no tenga perdida de información.</li>
</ol>
<p>Esta forma asegura la <u>no perdida de información</u> y la <u>conservación de las dependencias funcionales</u></p>

</body>
</html>