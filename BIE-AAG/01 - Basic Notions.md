# Basic Notions

**Alphabet:** A finite set of symbols (notation $\Sigma$ or T)

**String**: A sequence of symbols from an alphabet. Notation: 

- An empty sequence is written as $\epsilon$.
- $\Sigma^*$: Set of all strings of alphabet $\Sigma$
-  $\Sigma^+$: Set of all non empty strings of alphabet $\Sigma$

## Operations

### Concatenation 

Denoted as $"."$

$\forall x,y \in \Sigma^*$, the strings $x.y$ is created by concatenating strings $x$ and $y$. 

This operation:

- **Is associative**: 
  $$
  \forall x,y,z \in \Sigma^*: (xy)z = x(yz)
  $$

- **Is not commutative:**
  $$
  \exists x,y \in \Sigma^* : xy \neq yx
  $$

- **Has Identity element**
  $$
  \forall x \in \Sigma^* : \epsilon x = x\epsilon = x
  $$

- $a^0 = \epsilon, a^1 = a, a^2 = aa ...$

### Reversal

It reverses a string, with the following notation: $x^R$

For example: 
$$
x = a_0a_1a_2\dots a_n \\
x^R = a_na_{n-1}\dots a_1a_0
$$

### Length 

Denoted as $|x|$, It returns the amount of symbols in a string.
$$
|x| \geq 0
$$

## Formal Language

A formal language $L$ over $\Sigma: L\subseteq \Sigma^*$

We can apply the following operations:

- **Union**

- **Intersection**

- **Difference**

- **Complement**:
  $$
  L_1 : L_1 = \Sigma^* / L_1 (L_1 \cup L_1 = \Sigma^*, L_1 \cap L_1 = \empty)
  $$
  
- **Concatenation**:
  $$
  L = L_1.L_2 = \{xy:x\in L_1, y\in L_2 \}
  $$
  With $L$ defined over $\Sigma = \Sigma_1 \cup \Sigma_2$

- **$n^{th}$ power**.
  $$
  L:L^n = L.L^{n-1} \\
  L^0 = \{\epsilon\}
  $$
  Kleene star $L^*$ of language $L: L^* = \cup_{n=0}^{\infty} L^n$

  Kleene plus $L^+ = L.L^* = L^*.L = \cup_{n=0}^{\infty} L^n$

### Language generated by the grammar

The Language generated by a grammar is the set of all sentences generated by the grammar. Empty strings may be a sentences generated by the grammar. The formal definition for grammar $G = (N,\Sigma,P,S)$ is:
$$
L(G) = \{w : w\in \Sigma^*, \exists S \rightarrow^* w\}
$$

### Classification of Languages

The languages can be classified as:

- **Recursively Enumerable**: if it exists an *unrestricted* grammar which generates it.
- **Context-Sensitive**: if it exists a *context-sensitive* grammar which generates it.
- **Context-Free**: if it exists a *context-free* grammar which generates it.
- **Regular**: if it exists a *regular* grammar which generates it.

This classification works like an onion, where, for example, some recursively enumerable languages are also regular languages.

<img src="Resources/01 - Basic Notions/image-20201101114712073.png" alt="image-20201101114712073" style="zoom:50%;" />

If $L_1$ is regular and $L_2$ is not regular, then there exists $L_3$ that is regular and complies with the following:

- $L_1 \cup L_2 = L_3$
- $L_1 \cap L_2 = L_3$ 

### Finite Languages

We call a language $L \subset \Sigma^*$ **finite** if:
$$
\exists n \in \N / |L| \lt n
$$
We can also use the following **theorem**:

> The smallest class of languages that contains all finite languages and languages created from finite languages by a finite number of operations:
>
> - Union
> - Product
> - Kleene Star
> - Complement
>
> is the set (class) of **regular languages**.

### Context-Free Languages

#### Closure Properties of Context-Free Languages

According to the **closure property**, if certain languages are context-free, and a language $L$ is formed from them by certain operators, then  $L$ is also context-free. We can use the following **theorem**:

> The class if context-free languages is closed under the following operations: *union, product* and *iteration*.

#### Parse Tree for Context-free Languages

A **parse tree** is a graphical representation of a syntactical structure of a sentential form. A parse tree for a grammar $G = (N,\Sigma,P,S)$ has the following properties:

1. The nodes of the parse tree are labeled with the terminal symbol, nonterminal symbol and empty symbol ($\epsilon$).

2. The root of the tree is labeled with the start symbol $S$.

3. If a node has at least one descendant, it is labeled by a nonterminal symbol.

4. If $n_1,\dots,n_k$ are the direct descendants of node $n$ that is labeled with the symbols $A$ and these symbols are labeled with symbols $A_1,\dots,A)k$, then $P$ contains the following rule:
   $$
   A \rightarrow A_1 A_2 \dots A_k
   $$

5. The leaves of the parse tree from (from left to right), a sentential firm or a sentence in the grammar $G$. which is the result of the parse tree.

## Grammar

Grammar is a quadruple $G = (N,\Sigma,P,S)$ where:

- $N$ is a finite set of nonterminal symbols
- $\Sigma$ is a finite set of terminal symbols ($\Sigma \cap N = \empty$)
- $P$ is a set of production rules. It is a finite subset of $(N \cup \Sigma)^*.N.(N\cup\Sigma)^*\times(N\cup\Sigma)^*$, element $(\alpha,\beta)$ of $P$ is written as $\alpha \rightarrow\beta$ and called a rule)
- $S \in N$ is the *start* symbol of the grammar.

We say that $x$ derives $y$ in one step $(x\rightarrow y)$ if there exists $(\alpha \rightarrow \beta) \in P$ and $\delta \in (N \cup \Sigma)^*$ such that $x = \gamma\alpha\delta, y=\gamma\beta\delta$. For example:
$$
\gamma \alpha \delta \rightarrow \gamma \beta \delta
$$
$\alpha \rightarrow ^k \beta$ if there exist a sequence $a_0a_1\dots a_k$ $(k \geq 0)$ of $k+1$ strings such that $\alpha = \alpha_0,\alpha_{i-1} \rightarrow \alpha_i$ for $1 \leq i \leq k$ 

*<u>Transitive</u>* closure of relation $\rightarrow:$ $a\rightarrow^+ b$ if $a \rightarrow^i b$ for some $i \gt 0$. We read $\rightarrow^+$ as *derives in nonzero number of steps*.

<u>Transitive and Reflexive</u> closure of relation: $\alpha\rightarrow^* \beta$ if $\alpha\rightarrow ^i b$ for some $i \ge 0$. We read $\rightarrow^*$ as *derives in any number of steps*. 

A string $\alpha$ is called a <u>Sentential form</u> in grammar $G = (N,\Sigma,P,S)$ if:
$$
S \rightarrow^* \alpha, \alpha \in (N\cup\Sigma)^*
$$
Any string which is derived from start symbol. A sentential form that contains no nonterminal symbols is called a **sentence generated** by grammar $G$.

### Equivalent grammars

Grammars are equivalent if they generate the same language:
$$
L(G_1) = L(G_2)
$$

### Classification of Grammars

We say that a grammar $G = (N,\Sigma,P,S)$ is:

- **Unrestricted**: if it satisfies the general grammar definition.

- **Context-Sensitive**: if every rule from $P$ is of the form:
  $$
  \gamma A \delta \rightarrow \gamma \alpha \delta
  $$
  where $\gamma,\delta \in (N\cup \Sigma)^*$, $\alpha \in (N\cup \Sigma)^+$ and $A \in N$. Or the form of:
  $$
  S \rightarrow \epsilon
  $$
  if $S$ is not on the right side of any rule.

- **Context-Free**: If every rule is of the form:
  $$
  A \rightarrow \alpha
  $$
  where $A\in N, \alpha \in(N\cup \Sigma)^*$ 

- **Regular**: If every rule is of the form:
  $$
  \array{ \bullet & A \rightarrow aB\\
  \bullet & A \rightarrow a
  }
  $$
  where $A,B \in N, a \in \Sigma$. Or the form:
  $$
  S \rightarrow \epsilon
  $$
  if $S$ is not present in the right side of any rule.

### Operations Over Grammars

We can combine and mix different grammars to obtain the language we need. For this we can use the following operators and their algorithms:

- **Union**:

  <img src="Resources/01 - Basic Notions/image-20201101115735088.png" alt="image-20201101115735088" style="zoom:50%;" />

- **Product**:

  <img src="Resources/01 - Basic Notions/image-20201101115806249.png" alt="image-20201101115806249" style="zoom:50%;" />

- **Kleene Star** (also known as **iteration**):

  <img src="Resources/01 - Basic Notions/image-20201101115848309.png" alt="image-20201101115848309" style="zoom:50%;" />